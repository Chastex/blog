# 从 0 开始学微服务

## 到底什么是微服务？

> 微服务定义
>
> 微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。
>
> ——Martin Fowler 和 James Lewis

单体应用的问题

- 部署效率低
- 团队协作开发成本高
- 单点故障问题
- 线上发布变慢

服务化：本地方法调用 转为 远程方法调用（RPC）

微服务和服务化的差异：

- 服务拆分粒度更细
- 服务独立部署、维护
- 服务治理要求高

## 从单体应用走向服务化

### 什么时候进行服务化拆分？

经验：开发人员超过10人（沟通成本变高），就可以考虑服务化拆分

### 服务化拆分的两种姿势

**纵向拆分**，从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。

**横向拆分**，从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。

### 服务化拆分的前置条件

- **服务如何定义**。通过接口来约定。
- **服务如何发布和订阅**。通过服务注册和发现。
- **服务如何监控**。**故障如何定位**。服务化需要链路监控。
- **服务如何治理**。超时和重试、流量控制。

## 初探微服务架构

微服务通过注册中心，实现发布订阅模式。

服务调用主要依赖几个基本组件：

- 服务描述：常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。
  - RESTful API 代表：Swagger
  - XML 代表：Dubbo
  - IDL 代表：Thrift、gRPC
- 注册中心
  - 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。
  - 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。
  - 注册中心返回服务提供者地址列表给服务消费者。
  - 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。
- 服务框架
  - 通信协议：选择 TCP、UDP、HTTP，还是其他？
  - 数据传输方式：同步、异步、多路复用？
  - 序列化方式：JDK 序列化、Json、二进制（Protobuf、Thrift）？
- 服务监控
  - 数据采集
  - 数据处理
  - 数据展示
- 服务追踪
- 工作原理：通过 requestId、spanId 分别表示一次请求、请求中的某一环节
- 服务治理：
  - 超时、重试
  - 负载均衡
  - 故障转移
  - 流量控制

## 如何发布和引用服务？

**RESTful API**：主要被**用作 HTTP 或者 HTTPS 协议的接口定义**。代表：Eureka

**XML 配置**：代表：Dubbo。工作步骤：

- 服务提供者定义接口，并实现接口。
- 服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。
- 服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。

IDL 文件：IDL 就是接口描述语言（interface description language）的缩写。主要**用作跨语言平台的服务之间的调用**。有两种最常用的 IDL：Thrift、gRPC。

## 如何注册和发现服务？

微服务架构下，主要有三种角色：

- 服务提供者（RPC Server）
- 服务消费者（RPC Client）
- 服务注册中心（Registry）

### 注册中心实现方式

注册中心必须提供以下最基本的 API，例如：

- 服务注册接口
- 服务注销接口
- 心跳汇报接口
- 服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。
- 服务变更查询接口

- 服务查询接口
- 服务修改接口

### 集群部署

注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。

以 ZooKeeper 的工作原理为例：

- 每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。
- ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。
- Leader 负责处理数据更新等操作（ZAB 协议）。
- 一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。

### 目录存储

注册中心存储服务信息一般采用层次化的目录结构：

- 每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。
- znode 可以包含数据和子 znode。
- znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。

### 服务健康状态检测

ZooKeeper 客户端和服务端维持的是一个长连接。连接成功后，会生成一个全局唯一的 Session ID，客户端定期发送心跳消息，服务端收到后重置会话超时时间。如果超时，则认为连接结束。

如果一个服务将 ZooKeeper 作为服务注册中心，一旦连接超时，ZooKeeper 会认为这个服务节点已经不可用，就会将其信息删除。

### 服务状态变更通知

ZooKeeper 支持 Watch 机制。服务消费者可以监听服务提供者的节点信息。一旦服务提供者的节点信息哟变化，就可以获取到变更状态。

### 白名单机制

通常注册中心会有多套环境，区分开发、测试、线上等环境。如果弄错了，会出现意想不到的后果，为此需要引入白名单保护机制。只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。

## 如何实现RPC远程服务调用？

客户端和服务端如何建立网络连接？

- **HTTP 通信**：三次握手建立连接；四次挥手断开连接
- **Socket 通信**
  - 服务器监听
  - 客户端请求
  - 连接确认
  - 数据传输

服务端如何处理请求？

- BIO
- NIO
- AIO

数据传输采用什么协议？

- Http
- Dubbo

数据该如何序列化和反序列化？

- JDK
- JSON
- 二进制（PB、Thrift 等）

## 如何监控微服务调用？

监控对象

- 客户端监控
- 接口监控
- 资源监控
- 基础监控

监控指标

- 请求量
- 响应时间
- 错误率

监控维度

- 全局维度
- 机房维度
- 单机维度
- 时间维度
- 重要性维度

监控关键点

- 数据采集
  - 主动上报
  - 代理收集
- 数据传输
  - UDP
  - Kafka
- 数据处理
  - 全文检索：如 Elasticsearch
  - 时序数据库：如 InfluxDB、OpenTSDB
  - 流计算：如 Spark、Storm、Flink
- 数据展示

## 如何追踪微服务调用？

### 服务追踪的作用

- 定位整个系统的瓶颈点
- 优化链路调用
- 生成网络拓扑
- 透明传输数据

### 服务追踪系统原理

经典论文：[`Dapper, a Large-Scale Distributed Systems Tracing Infrastructure`](http://bigbully.github.io/Dapper-translation/)

- **traceId**，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。
- **spanId**，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。
- **annotation**，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。

### 服务追踪系统实现

服务追踪系统可以分为三层。

- 数据采集层，负责数据埋点并上报。
- 数据处理层，负责数据的存储与计算。
- 数据展示层，负责数据的图形化展示。
