<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">31</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">note/数据密集型应用系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 23:33:01" itemprop="dateCreated datePublished" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="note/数据密集型应用系统设计/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据密集型应用系统设计"><a class="markdownIt-Anchor" href="#数据密集型应用系统设计"></a> 数据密集型应用系统设计</h1>
<h2 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h2>
<p>复制主要指通过互联网络在多台机器上保存相同数据的副本。</p>
<p>数据复制的作用：</p>
<ul>
<li>使数据在地理位置上更接近用户，从而<strong>降低访问延迟</strong>。</li>
<li>当部分组件出现位障，系统依然可以继续工作，从而<strong>提高可用性</strong>。</li>
<li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong>。</li>
</ul>
<p>复制方式：</p>
<ul>
<li>主从复制</li>
<li>多主节点复制</li>
<li>无主节点复制</li>
</ul>
<p>复制需要考虑的问题：</p>
<ul>
<li>同步还是异步</li>
<li>如何处理失败的副本</li>
<li>如何保证数据一致</li>
</ul>
<h3 id="主节点与从节点"><a class="markdownIt-Anchor" href="#主节点与从节点"></a> 主节点与从节点</h3>
<p>每个保存数据库完整数据集的节点称之为副本。</p>
<p>主从复制的工作原理如下：</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求：从客户端的角度来看，从副本都是只读的。</li>
</ol>
<p>许多关系型数据库都内置支持主从复制，例如 PostgreSQL (9.0 版本以后）、MySQL 、Oracle Data Guard 和 SQL Server 的 AlwaysOn Availabilitiy Groups 。而一些非关系数据库如 MongoDB 、RethinkDB 和 Espresso 也支持主从复制。另外， 主从复制技术也不仅限于数据库，还广泛用于分布式悄息队列如 Kafka 和 RabbitMQ。</p>
<h3 id="同步复制与异步复制"><a class="markdownIt-Anchor" href="#同步复制与异步复制"></a> 同步复制与异步复制</h3>
<ul>
<li><strong>同步复制的优点</strong>： 一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</li>
<li><strong>同步复制的缺点</strong>：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因）， 写入就不能视为成功。主节点会阻塞其后所有的写操作，直到同步副本确认完成。</li>
</ul>
<p>因此，把所有从节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。</p>
<ul>
<li><strong>异步复制的优点</strong>：不管从节点上数据多么滞后， 主节点总是可以继续响应写请求，系统的吞吐性能更好。</li>
<li><strong>异步复制的缺点</strong>：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。</li>
</ul>
<h3 id="配置新的从节点"><a class="markdownIt-Anchor" href="#配置新的从节点"></a> 配置新的从节点</h3>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具， 如 MySQL 的 innobackupex。</li>
<li>将此快照拷贝到新的从节点。</li>
<li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称呼，如 PostgreSQL 将其称为“ log sequence number” （日志序列号），而 MySQL 将其称为“ binlog coordinates ” 。</li>
<li>获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化。井重复步骤 1 ～步骤 4 。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异。</p>
<h3 id="处理节点失效"><a class="markdownIt-Anchor" href="#处理节点失效"></a> 处理节点失效</h3>
<p>如何通过主从复制技术来实现系统高可用呢？</p>
<h4 id="从节点失效-追赶式恢复"><a class="markdownIt-Anchor" href="#从节点失效-追赶式恢复"></a> 从节点失效： 追赶式恢复</h4>
<p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点发生崩溃，然后顺利重启，或者主从节点之间的网络发生暂时中断（闪断），则恢复比较容易，根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p>
<h4 id="主节点失效节点切换"><a class="markdownIt-Anchor" href="#主节点失效节点切换"></a> 主节点失效：节点切换</h4>
<p>选择某个从节点将其提升为主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这一过程称之为切换。</p>
<p>步骤通常如下：</p>
<ol>
<li><strong>确认主节点失效</strong>。有很多种出错可能性，所以大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳悄息，如果发现某一个节点在一段比较长时间内（例如 30s ）没有响应，即认为该节点发生失效。</li>
<li><strong>选举新的主节点</strong>。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。让所有节点同意新的主节点是个典型的共识问题。</li>
<li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</li>
</ol>
<p>上述切换过程依然充满了很多变数：</p>
<ul>
<li>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作会发生什么？新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</li>
<li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。例如，在 GitHub 的一个事故中，某个数据并非完全同步的 MySQL 从节点被提升为主副本，数据库使用了自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（ 即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部 Redis 所引用，结果出现 MySQL 和 Redis 之间的不一致，最后导致了某些私有数据被错误地泄露给了其他用户。</li>
<li>在某些故障情况下，可能会发生两个节点同时－都自认为是主节点。这种情况被称为<strong>脑裂</strong>，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法（参阅本章后面的“多主节点复制技术”），最后数据可<br />
能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。然而，如果设计或者实现考虑不周，可能会出现两个节点都被关闭的情况。</li>
<li>如何设置合适的超时来检测主节点失效呢？ 主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。但如果超时设置太短，可能会导致很多不必要的切换。例如，突发的负载峰值会导致节点的响应时间变长甚至超肘，或者由于网络故障导致延迟增加。如果系统此时已经处于高负载压力或网络已经出现严重拥塞，不必要的切换操作只会使总体情况变得更糟。</li>
</ul>
<h4 id="复制日志的实现"><a class="markdownIt-Anchor" href="#复制日志的实现"></a> 复制日志的实现</h4>
<h5 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h5>
<p>最简单的情况，主节点记录所执行的每个写请求（操作语句）井将该操作语句作为日志发送给从节点。对于关系数据库，这意味着每个 INSERT 、UPDATE 或 DELETE 语句都会转发给从节点，并且每个从节点都会分析井执行这些 SQU 吾句，如同它们是来自客户端那样。</p>
<p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p>
<ul>
<li>任何调用非确定性函数的语句，如 <code>NOW()</code> 获取当前时间，或 <code>RAND()</code> 获取一个随机数等，可能会在不同的副本上产生不同的值。</li>
<li>如果语句中使用了自增列，或者依赖于数据库的现有数据（例如， <code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行的事务时， 会有很大的限制。</li>
<li>有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用。</li>
</ul>
<p>有可能采取一些特殊措施来解决这些问题，例如，主节点可以在记录操作语句时将非确定性函数替换为执行之后的确定的结果，这样所有节点直接使用相同的结果值。但是，这里面存在太多边界条件需要考虑，因此目前通常首选的是其他复制实现方案。</p>
<p>MySQL 5.1 版本之前采用基于操作语句的复制。现在由于逻辑紧凑，依然在用，但是默认情况下，如果语句中存在一些不确定性操作，则 MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用基于语句的复制，它通过事务级别的确定性来保证复制的安全。</p>
<h5 id="基于预写日志wal传输"><a class="markdownIt-Anchor" href="#基于预写日志wal传输"></a> 基于预写日志（WAL）传输</h5>
<p>通常每个写操作都是以追加写的方式写入到日志中：</p>
<ul>
<li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li>
<li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩愤，通过索引更新的方式迅速恢复到此前－致状态。</li>
</ul>
<p>不管哪种情况，所有对数据库写入的字节序列都被记入日志。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外， 主节点还可以通过网络将其发送给从节点。</p>
<p>PostgreSQL 、Oracle 以及其他系统等支持这种复制方式。其主要缺点是日志描述的数据结果非常底层： 一个 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密搞合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无能支持主从节点上运行不同版本的软件。</p>
<h5 id="基于行的逻辑日志复制"><a class="markdownIt-Anchor" href="#基于行的逻辑日志复制"></a> 基于行的逻辑日志复制</h5>
<p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值。</li>
<li>对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。</li>
<li>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。</li>
</ul>
<p>如果一条事务涉及多行的修改，贝 lj 会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。MySQL 的二进制日志 binl og （当配置为基于行的复制时）使用该方式。</p>
<p>由于逻辑日志与存储引擎逻辑解锢，因此可以更容易地保持向后兼容，从而使主从节点能够运行不同版本的软件甚至是不同的存储引擎。<br />
对于外部应用程序来说，逻辑日志格式也更容易解析。</p>
<h5 id="基于触发器的复制"><a class="markdownIt-Anchor" href="#基于触发器的复制"></a> 基于触发器的复制</h5>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。Oracle 的 Databus 和 Postgres 的 Bucardo 就是这种技术的典型代表。基于触发器的复制通常比其他复制方式开销更高， 也比数据库内置复制更容易出错，或者暴露一些限制。然而，其高度灵活性仍有用武之地。</p>
<h3 id="复制滞后问题"><a class="markdownIt-Anchor" href="#复制滞后问题"></a> 复制滞后问题</h3>
<p>主从复制要求所有写请求都经由主节点，而任何副本只能接受只读查询。对于读操作密集的负载（如Web ），这是一个不错的选择：创建多个从副本，将读请求分发给这些从副本，从而减轻主节点负载井允许读取请求就近满足。</p>
<p>在这种扩展体系下，只需添加更多的从副本，就可以提高读请求的服务吞吐量。但是，这种方怯实际上只能用于异步复制，如果试图同步复制所有的从副本，则单个节点故障或网络中断将使整个系统无能写入。而且节点越多，发生故障的概率越高，所以完全同步的配置现实中反而非常不可靠。</p>
<p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点， 贝lj应用可能会读到过期的信息。这会导致数据库中出现明显的不一致：由于并非所有的写入都反映在从副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的结果。这种效应也破称为最终一致性。</p>
<h3 id="读自己的写"><a class="markdownIt-Anchor" href="#读自己的写"></a> 读自己的写</h3>
<p>许多应用让用户提交一些数据，接下来查看他们自己所提交的内容。例如客户数据库<br />
中的记录，亦或者是讨论主题的评论等。提交新数据须发送到主节点，但是当用户读<br />
取数据时，数据可能来自从节点。这对于读密集和偶尔写入的负载是个非常合适的方<br />
案。<br />
然而对于异步复制存在这样一个问题，如图5-3 所示，用户在写人不久即查看数据，<br />
则新数据可能尚未到达从节点。对用户来讲， 看起来似乎是刚刚提交的数据丢失了，<br />
显然用户不会高兴。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">note/架构实战案例解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 23:33:01" itemprop="dateCreated datePublished" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="note/架构实战案例解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>708</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="架构实战案例解析"><a class="markdownIt-Anchor" href="#架构实战案例解析"></a> 架构实战案例解析</h1>
<h2 id="架构的本质如何打造一个有序的系统"><a class="markdownIt-Anchor" href="#架构的本质如何打造一个有序的系统"></a> 架构的本质：如何打造一个有序的系统？</h2>
<p><strong>架构的本质</strong>：通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。</p>
<p>首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。</p>
<p>其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。</p>
<p><strong>架构的分类</strong></p>
<ul>
<li>业务架构</li>
<li>应用架构</li>
<li>技术架构</li>
</ul>
<p><strong>架构师的自我修养</strong></p>
<ul>
<li>优秀的程序员</li>
<li>沟通交流</li>
<li>权衡取舍</li>
<li>多领域知识</li>
<li>技术前瞻性</li>
<li>看透问题本质</li>
<li>抽象思维</li>
</ul>
<h2 id="业务架构作为开发你真的了解业务吗"><a class="markdownIt-Anchor" href="#业务架构作为开发你真的了解业务吗"></a> 业务架构：作为开发，你真的了解业务吗？</h2>
<p>产品经理的职责是定义产品的外观。</p>
<p>架构师的职责是将业务抽象为结构化的模块体系。</p>
<h2 id="可扩展架构如何打造一个善变的柔性系统"><a class="markdownIt-Anchor" href="#可扩展架构如何打造一个善变的柔性系统"></a> 可扩展架构：如何打造一个善变的柔性系统？</h2>
<p>系统 = 模块 + 关系</p>
<p>模块的要求：</p>
<ul>
<li>定位明确，概念完整</li>
<li>自成体系，粒度适中</li>
</ul>
<p>依赖关系的要求：</p>
<ul>
<li>最好是单向的</li>
<li>最好是层次化结构</li>
</ul>
<p>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p>
<h2 id="可扩展架构案例一电商平台架构是如何演变的"><a class="markdownIt-Anchor" href="#可扩展架构案例一电商平台架构是如何演变的"></a> 可扩展架构案例（一）：电商平台架构是如何演变的？</h2>
<p>电商平台的大致发展：</p>
<p>单体 -&gt; 分布式 -&gt; SOA -&gt; 微服务 -&gt; 中台</p>
<p>SOA vs. 微服务</p>
<ul>
<li>SOA 中的 ESB 采用集中式管理</li>
<li>微服务采用去中心化管理</li>
</ul>
<h2 id="可扩展架构案例二app-服务端架构是如何升级的"><a class="markdownIt-Anchor" href="#可扩展架构案例二app-服务端架构是如何升级的"></a> 可扩展架构案例（二）：App 服务端架构是如何升级的？</h2>
<h2 id="可扩展架构案例三你真的需要一个中台吗"><a class="markdownIt-Anchor" href="#可扩展架构案例三你真的需要一个中台吗"></a> 可扩展架构案例（三）：你真的需要一个中台吗？</h2>
<p>前台：面向 C 端的应用</p>
<p>后台：企业内部系统</p>
<p>中台：通过实现基础业务的平台化，实现了企业级业务能力的快速复用</p>
<h2 id="可复用架构如何实现高层次的复用"><a class="markdownIt-Anchor" href="#可复用架构如何实现高层次的复用"></a> 可复用架构：如何实现高层次的复用？</h2>
<p>技术复用</p>
<ul>
<li>代码复用</li>
<li>组件复用</li>
</ul>
<p>业务复用</p>
<h2 id="可复用架构案例一如何设计一个基础服务"><a class="markdownIt-Anchor" href="#可复用架构案例一如何设计一个基础服务"></a> 可复用架构案例（一）：如何设计一个基础服务？</h2>
<h2 id="可复用架构案例二如何对现有系统做微服务改造"><a class="markdownIt-Anchor" href="#可复用架构案例二如何对现有系统做微服务改造"></a> 可复用架构案例（二）：如何对现有系统做微服务改造？</h2>
<h2 id="可复用架构案例三中台是如何炼成的"><a class="markdownIt-Anchor" href="#可复用架构案例三中台是如何炼成的"></a> 可复用架构案例（三）：中台是如何炼成的？</h2>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a href="https://time.geekbang.org/column/intro/100046301" target="_blank" rel="noopener">架构实战案例解析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">从0开始学微服务学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 15:27:00" itemprop="dateCreated datePublished" datetime="2021-08-15T15:27:00+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="note/从0开始学微服务/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从-0-开始学微服务学习笔记"><a class="markdownIt-Anchor" href="#从-0-开始学微服务学习笔记"></a> 从 0 开始学微服务学习笔记</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1">1. 到底什么是微服务？</a></li>
<li><a href="#2-%E4%BB%8E%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E8%B5%B0%E5%90%91%E6%9C%8D%E5%8A%A1%E5%8C%96">2. 从单体应用走向服务化</a>
<ul>
<li><a href="#21-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86">2.1. 什么时候进行服务化拆分？</a></li>
<li><a href="#22-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A7%BF%E5%8A%BF">2.2. 服务化拆分的两种姿势</a></li>
<li><a href="#23-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6">2.3. 服务化拆分的前置条件</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%9D%E6%8E%A2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">3. 初探微服务架构</a></li>
<li><a href="#4-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">4. 如何发布和引用服务？</a></li>
<li><a href="#5-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1">5. 如何注册和发现服务？</a>
<ul>
<li><a href="#51-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">5.1. 注册中心实现方式</a></li>
<li><a href="#52-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">5.2. 集群部署</a></li>
<li><a href="#53-%E7%9B%AE%E5%BD%95%E5%AD%98%E5%82%A8">5.3. 目录存储</a></li>
<li><a href="#54-%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B">5.4. 服务健康状态检测</a></li>
<li><a href="#55-%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E9%80%9A%E7%9F%A5">5.5. 服务状态变更通知</a></li>
<li><a href="#56-%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6">5.6. 白名单机制</a></li>
</ul>
</li>
<li><a href="#6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rpc-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">6. 如何实现 RPC 远程服务调用？</a></li>
<li><a href="#7-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">7. 如何监控微服务调用？</a></li>
<li><a href="#8-%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">8. 如何追踪微服务调用？</a>
<ul>
<li><a href="#81-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%9A%84%E4%BD%9C%E7%94%A8">8.1. 服务追踪的作用</a></li>
<li><a href="#82-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">8.2. 服务追踪系统原理</a></li>
<li><a href="#83-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">8.3. 服务追踪系统实现</a></li>
</ul>
</li>
<li><a href="#9-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B">9. 微服务治理的手段有哪些？</a>
<ul>
<li><a href="#91-%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86">9.1. 节点管理</a></li>
<li><a href="#92-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">9.2. 负载均衡</a></li>
<li><a href="#93-%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">9.3. 服务路由</a></li>
<li><a href="#94-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99">9.4. 服务容错</a></li>
</ul>
</li>
<li><a href="#10-dubbo-%E6%A1%86%E6%9E%B6%E9%87%8C%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6">10. Dubbo 框架里的微服务组件</a></li>
<li><a href="#11-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E8%B7%B5">11. 服务发布和引用的实践</a></li>
<li><a href="#12-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0">12. 如何将注册中心落地？</a>
<ul>
<li><a href="#121-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">12.1. 注册中心工作流程</a></li>
<li><a href="#122-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%8A%82%E7%82%B9">12.2. 如何注册节点</a></li>
<li><a href="#123-%E5%A6%82%E4%BD%95%E5%8F%8D%E6%B3%A8%E5%86%8C">12.3. 如何反注册</a></li>
<li><a href="#124-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF">12.4. 如何查询节点信息</a></li>
<li><a href="#125-%E5%A6%82%E4%BD%95%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1%E5%8F%98%E6%9B%B4">12.5. 如何订阅服务变更</a></li>
<li><a href="#126-%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98">12.6. 注册与发现的几个问题</a></li>
</ul>
</li>
<li><a href="#13-%E5%BC%80%E6%BA%90%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">13. 开源服务注册中心如何选型？</a></li>
<li><a href="#14-%E5%BC%80%E6%BA%90-rpc-%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">14. 开源 RPC 框架如何选型？</a></li>
<li><a href="#15-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F">15. 如何搭建一个可靠的监控系统？</a></li>
<li><a href="#16-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F">16. 如何搭建一套适合你的服务追踪系统？</a></li>
<li><a href="#17-%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB">17. 如何识别服务节点是否存活？</a>
<ul>
<li><a href="#171-%E5%BF%83%E8%B7%B3%E5%BC%80%E5%85%B3%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.1. 心跳开关保护机制</a></li>
<li><a href="#172-%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%91%98%E9%99%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.2. 服务节点摘除保护机制</a></li>
</ul>
</li>
<li><a href="#18-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18. 如何使用负载均衡算法？</a>
<ul>
<li><a href="#181-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18.1. 负载均衡算法</a></li>
</ul>
</li>
<li><a href="#19-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">19. 如何使用服务路由？</a></li>
<li><a href="#20-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9">20. 服务端出现故障时该如何应对？</a></li>
<li><a href="#21-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%89%8B%E6%AE%B5">21. 服务调用失败时有哪些处理手段？</a></li>
<li><a href="#22-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE">22. 如何管理服务配置？</a></li>
<li><a href="#23-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0">23. 如何搭建微服务治理平台？</a></li>
<li><a href="#24-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AF%A5%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0">24. 微服务架构该如何落地？</a></li>
<li><a href="#25-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%B9%E5%99%A8%E5%8C%96">25. 微服务为什么要容器化？</a></li>
<li><a href="#26-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6">26. 微服务容器化运维：镜像仓库和资源调度</a></li>
<li><a href="#27-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AE%B9%E5%99%A8%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92">27. 微服务容器化运维：容器调度和服务编排</a></li>
<li><a href="#28-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%BE%AE%E5%8D%9A%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0-dcp">28. 微服务容器化运维：微博容器运维平台 DCP</a></li>
<li><a href="#29-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-devops">29. 微服务如何实现 DevOps？</a></li>
<li><a href="#30-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92">30. 如何做好微服务容量规划？</a></li>
<li><a href="#31-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E6%9C%BA%E6%88%BF%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">31. 微服务多机房部署实践</a></li>
<li><a href="#32-%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">32. 多机房数据同步</a></li>
<li><a href="#33-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B7%B7%E5%90%88%E4%BA%91%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">33. 微服务混合云部署实践</a>
<ul>
<li><a href="#331-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">33.1. 跨云服务的负载均衡</a></li>
<li><a href="#332-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">33.2. 跨云服务的数据同步</a></li>
<li><a href="#333-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4">33.3. 跨云服务的容器运维</a></li>
</ul>
</li>
<li><a href="#34-%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-service-mesh">34. 下一代微服务架构 Service Mesh</a></li>
<li><a href="#35-service-mesh-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">35. Service Mesh 的实现原理</a></li>
<li><a href="#36-istioservice-mesh%E7%9A%84%E4%BB%A3%E8%A1%A8%E4%BA%A7%E5%93%81">36. Istio：Service Mesh 的代表产品</a>
<ul>
<li><a href="#361-istio-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">36.1. Istio 整体架构</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-到底什么是微服务"><a class="markdownIt-Anchor" href="#1-到底什么是微服务"></a> 1. 到底什么是微服务？</h2>
<blockquote>
<p>微服务定义</p>
<p>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。</p>
<p>——Martin Fowler 和 James Lewis</p>
</blockquote>
<p>单体应用的问题</p>
<ul>
<li>部署效率低</li>
<li>团队协作开发成本高</li>
<li>单点故障问题</li>
<li>线上发布变慢</li>
</ul>
<p>服务化：本地方法调用 转为 远程方法调用（RPC）</p>
<p>微服务和服务化的差异：</p>
<ul>
<li>服务拆分粒度更细</li>
<li>服务独立部署、维护</li>
<li>服务治理要求高</li>
</ul>
<h2 id="2-从单体应用走向服务化"><a class="markdownIt-Anchor" href="#2-从单体应用走向服务化"></a> 2. 从单体应用走向服务化</h2>
<h3 id="21-什么时候进行服务化拆分"><a class="markdownIt-Anchor" href="#21-什么时候进行服务化拆分"></a> 2.1. 什么时候进行服务化拆分？</h3>
<p>经验：开发人员超过 10 人（沟通成本变高），就可以考虑服务化拆分</p>
<h3 id="22-服务化拆分的两种姿势"><a class="markdownIt-Anchor" href="#22-服务化拆分的两种姿势"></a> 2.2. 服务化拆分的两种姿势</h3>
<p><strong>纵向拆分</strong>，从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p><strong>横向拆分</strong>，从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<h3 id="23-服务化拆分的前置条件"><a class="markdownIt-Anchor" href="#23-服务化拆分的前置条件"></a> 2.3. 服务化拆分的前置条件</h3>
<ul>
<li><strong>服务如何定义</strong>。通过接口来约定。</li>
<li><strong>服务如何发布和订阅</strong>。通过服务注册和发现。</li>
<li><strong>服务如何监控</strong>。<strong>故障如何定位</strong>。服务化需要链路监控。</li>
<li><strong>服务如何治理</strong>。超时和重试、流量控制。</li>
</ul>
<h2 id="3-初探微服务架构"><a class="markdownIt-Anchor" href="#3-初探微服务架构"></a> 3. 初探微服务架构</h2>
<p>微服务通过注册中心，实现发布订阅模式。</p>
<p>服务调用主要依赖几个基本组件：</p>
<ul>
<li>服务描述：常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。
<ul>
<li>RESTful API 代表：Swagger</li>
<li>XML 代表：Dubbo</li>
<li>IDL 代表：Thrift、gRPC</li>
</ul>
</li>
<li>注册中心
<ul>
<li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li>
<li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li>
<li>注册中心返回服务提供者地址列表给服务消费者。</li>
<li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li>
</ul>
</li>
<li>服务框架
<ul>
<li>通信协议：选择 TCP、UDP、HTTP，还是其他？</li>
<li>数据传输方式：同步、异步、多路复用？</li>
<li>序列化方式：JDK 序列化、Json、二进制（Protobuf、Thrift）？</li>
</ul>
</li>
<li>服务监控
<ul>
<li>数据采集</li>
<li>数据处理</li>
<li>数据展示</li>
</ul>
</li>
<li>服务追踪</li>
<li>工作原理：通过 requestId、spanId 分别表示一次请求、请求中的某一环节</li>
<li>服务治理：
<ul>
<li>超时、重试</li>
<li>负载均衡</li>
<li>故障转移</li>
<li>流量控制</li>
</ul>
</li>
</ul>
<h2 id="4-如何发布和引用服务"><a class="markdownIt-Anchor" href="#4-如何发布和引用服务"></a> 4. 如何发布和引用服务？</h2>
<p><strong>RESTful API</strong>：主要被<strong>用作 HTTP 或者 HTTPS 协议的接口定义</strong>。代表：Eureka</p>
<p><strong>XML 配置</strong>：代表：Dubbo。工作步骤：</p>
<ul>
<li>服务提供者定义接口，并实现接口。</li>
<li>服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。</li>
<li>服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。</li>
</ul>
<p>IDL 文件：IDL 就是接口描述语言（interface description language）的缩写。主要<strong>用作跨语言平台的服务之间的调用</strong>。有两种最常用的 IDL：Thrift、gRPC。</p>
<h2 id="5-如何注册和发现服务"><a class="markdownIt-Anchor" href="#5-如何注册和发现服务"></a> 5. 如何注册和发现服务？</h2>
<p>微服务架构下，主要有三种角色：</p>
<ul>
<li>服务提供者（RPC Server）</li>
<li>服务消费者（RPC Client）</li>
<li>服务注册中心（Registry）</li>
</ul>
<h3 id="51-注册中心实现方式"><a class="markdownIt-Anchor" href="#51-注册中心实现方式"></a> 5.1. 注册中心实现方式</h3>
<p>注册中心必须提供以下最基本的 API，例如：</p>
<ul>
<li>
<p>服务注册接口</p>
</li>
<li>
<p>服务注销接口</p>
</li>
<li>
<p>心跳汇报接口</p>
</li>
<li>
<p>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</p>
</li>
<li>
<p>服务变更查询接口</p>
</li>
<li>
<p>服务查询接口</p>
</li>
<li>
<p>服务修改接口</p>
</li>
</ul>
<h3 id="52-集群部署"><a class="markdownIt-Anchor" href="#52-集群部署"></a> 5.2. 集群部署</h3>
<p>注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>以 ZooKeeper 的工作原理为例：</p>
<ul>
<li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li>
<li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li>
<li>Leader 负责处理数据更新等操作（ZAB 协议）。</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li>
</ul>
<h3 id="53-目录存储"><a class="markdownIt-Anchor" href="#53-目录存储"></a> 5.3. 目录存储</h3>
<p>注册中心存储服务信息一般采用层次化的目录结构：</p>
<ul>
<li>每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。</li>
<li>znode 可以包含数据和子 znode。</li>
<li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<h3 id="54-服务健康状态检测"><a class="markdownIt-Anchor" href="#54-服务健康状态检测"></a> 5.4. 服务健康状态检测</h3>
<p>ZooKeeper 客户端和服务端维持的是一个长连接。连接成功后，会生成一个全局唯一的 Session ID，客户端定期发送心跳消息，服务端收到后重置会话超时时间。如果超时，则认为连接结束。</p>
<p>如果一个服务将 ZooKeeper 作为服务注册中心，一旦连接超时，ZooKeeper 会认为这个服务节点已经不可用，就会将其信息删除。</p>
<h3 id="55-服务状态变更通知"><a class="markdownIt-Anchor" href="#55-服务状态变更通知"></a> 5.5. 服务状态变更通知</h3>
<p>ZooKeeper 支持 Watch 机制。服务消费者可以监听服务提供者的节点信息。一旦服务提供者的节点信息哟变化，就可以获取到变更状态。</p>
<h3 id="56-白名单机制"><a class="markdownIt-Anchor" href="#56-白名单机制"></a> 5.6. 白名单机制</h3>
<p>通常注册中心会有多套环境，区分开发、测试、线上等环境。如果弄错了，会出现意想不到的后果，为此需要引入白名单保护机制。只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h2 id="6-如何实现-rpc-远程服务调用"><a class="markdownIt-Anchor" href="#6-如何实现-rpc-远程服务调用"></a> 6. 如何实现 RPC 远程服务调用？</h2>
<p>客户端和服务端如何建立网络连接？</p>
<ul>
<li><strong>HTTP 通信</strong>：三次握手建立连接；四次挥手断开连接</li>
<li><strong>Socket 通信</strong>
<ul>
<li>服务器监听</li>
<li>客户端请求</li>
<li>连接确认</li>
<li>数据传输</li>
</ul>
</li>
</ul>
<p>服务端如何处理请求？</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<p>数据传输采用什么协议？</p>
<ul>
<li>Http</li>
<li>Dubbo</li>
</ul>
<p>数据该如何序列化和反序列化？</p>
<ul>
<li>JDK</li>
<li>JSON</li>
<li>二进制（PB、Thrift 等）</li>
</ul>
<h2 id="7-如何监控微服务调用"><a class="markdownIt-Anchor" href="#7-如何监控微服务调用"></a> 7. 如何监控微服务调用？</h2>
<p>监控对象</p>
<ul>
<li>客户端监控</li>
<li>接口监控</li>
<li>资源监控</li>
<li>基础监控</li>
</ul>
<p>监控指标</p>
<ul>
<li>请求量</li>
<li>响应时间</li>
<li>错误率</li>
</ul>
<p>监控维度</p>
<ul>
<li>全局维度</li>
<li>机房维度</li>
<li>单机维度</li>
<li>时间维度</li>
<li>重要性维度</li>
</ul>
<p>监控关键点</p>
<ul>
<li>数据采集
<ul>
<li>主动上报</li>
<li>代理收集</li>
</ul>
</li>
<li>数据传输
<ul>
<li>UDP</li>
<li>Kafka</li>
</ul>
</li>
<li>数据处理
<ul>
<li>全文检索：如 Elasticsearch</li>
<li>时序数据库：如 InfluxDB、OpenTSDB</li>
<li>流计算：如 Spark、Storm、Flink</li>
</ul>
</li>
<li>数据展示</li>
</ul>
<h2 id="8-如何追踪微服务调用"><a class="markdownIt-Anchor" href="#8-如何追踪微服务调用"></a> 8. 如何追踪微服务调用？</h2>
<h3 id="81-服务追踪的作用"><a class="markdownIt-Anchor" href="#81-服务追踪的作用"></a> 8.1. 服务追踪的作用</h3>
<ul>
<li>定位整个系统的瓶颈点</li>
<li>优化链路调用</li>
<li>生成网络拓扑</li>
<li>透明传输数据</li>
</ul>
<h3 id="82-服务追踪系统原理"><a class="markdownIt-Anchor" href="#82-服务追踪系统原理"></a> 8.2. 服务追踪系统原理</h3>
<p>经典论文：<a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener"><code>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</code></a></p>
<ul>
<li><strong>traceId</strong>，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><strong>spanId</strong>，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><strong>annotation</strong>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li>
</ul>
<h3 id="83-服务追踪系统实现"><a class="markdownIt-Anchor" href="#83-服务追踪系统实现"></a> 8.3. 服务追踪系统实现</h3>
<p>服务追踪系统可以分为三层。</p>
<ul>
<li>数据采集层，负责数据埋点并上报。</li>
<li>数据处理层，负责数据的存储与计算。</li>
<li>数据展示层，负责数据的图形化展示。</li>
</ul>
<h2 id="9-微服务治理的手段有哪些"><a class="markdownIt-Anchor" href="#9-微服务治理的手段有哪些"></a> 9. 微服务治理的手段有哪些？</h2>
<p>服务调用失败原因：</p>
<ul>
<li>服务提供者自身问题，如宕机、进程退出等；</li>
<li>网络问题</li>
</ul>
<h3 id="91-节点管理"><a class="markdownIt-Anchor" href="#91-节点管理"></a> 9.1. 节点管理</h3>
<ul>
<li><strong>注册中心主动摘除机制</strong>：服务提供者定时发送心跳，如果超时，注册中心把节点从服务列表中删除</li>
<li><strong>服务消费者摘除机制</strong>：如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除。</li>
</ul>
<h3 id="92-负载均衡"><a class="markdownIt-Anchor" href="#92-负载均衡"></a> 9.2. 负载均衡</h3>
<ul>
<li>随机算法</li>
<li>轮询算法</li>
<li>最少活跃调用算法</li>
<li>一致性 Hash 算法</li>
</ul>
<h3 id="93-服务路由"><a class="markdownIt-Anchor" href="#93-服务路由"></a> 9.3. 服务路由</h3>
<p>为什么要制定路由规则呢？</p>
<ul>
<li>业务存在灰度发布的需求</li>
<li>多机房就近访问的需求</li>
</ul>
<p>如何配置路由规则</p>
<ul>
<li>静态配置：修改服务消费者本地配置，上线后生效</li>
<li>动态配置：修改注册中心的配置，服务消费者在下一个同步周期之后，就会动态更新</li>
</ul>
<h3 id="94-服务容错"><a class="markdownIt-Anchor" href="#94-服务容错"></a> 9.4. 服务容错</h3>
<ul>
<li>FailOver：失败自动切换。</li>
<li>FailBack：失败通知。</li>
<li>FailCache：失败缓存。</li>
<li>FailFast：快速失败。</li>
</ul>
<p>一般情况下对于幂等的调用，可以选择 FailOver 或者 FailCache，非幂等的调用可以选择 FailBack 或者 FailFast。</p>
<h2 id="10-dubbo-框架里的微服务组件"><a class="markdownIt-Anchor" href="#10-dubbo-框架里的微服务组件"></a> 10. Dubbo 框架里的微服务组件</h2>
<h2 id="11-服务发布和引用的实践"><a class="markdownIt-Anchor" href="#11-服务发布和引用的实践"></a> 11. 服务发布和引用的实践</h2>
<p>XML 配置方式的服务发布和引用流程</p>
<ul>
<li>服务提供者定义接口</li>
<li>服务提供者发布接口</li>
<li>服务消费者引用接口</li>
</ul>
<p>服务发布和引用的那些坑</p>
<h2 id="12-如何将注册中心落地"><a class="markdownIt-Anchor" href="#12-如何将注册中心落地"></a> 12. 如何将注册中心落地？</h2>
<p>注册中心如何存储服务信息</p>
<p>服务一般会分成多个不同的分组</p>
<ul>
<li>核心与非核心，从业务的核心程度来分。</li>
<li>机房，从机房的维度来分。</li>
<li>线上环境与测试环境，从业务场景维度来区分。</li>
</ul>
<p>所以注册中心存储的服务信息一般包含三部分内容：<strong>分组</strong>、<strong>服务名</strong>以及<strong>节点信息</strong>，节点信息又包括节点地址和节点其他信息。</p>
<h3 id="121-注册中心工作流程"><a class="markdownIt-Anchor" href="#121-注册中心工作流程"></a> 12.1. 注册中心工作流程</h3>
<ul>
<li>服务提供者注册流程。</li>
<li>服务提供者反注册流程。</li>
<li>服务消费者查询流程。</li>
<li>服务消费者订阅变更流程。</li>
</ul>
<h3 id="122-如何注册节点"><a class="markdownIt-Anchor" href="#122-如何注册节点"></a> 12.2. 如何注册节点</h3>
<ul>
<li>首先查看要注册的节点是否在白名单内？如果不在就抛出异常，在的话继续下一步。</li>
<li>其次要查看注册的 Cluster（服务的接口名）是否存在？如果不存在就抛出异常，存在的话继续下一步。</li>
<li>然后要检查 Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下一步。</li>
<li>最后将节点信息添加到对应的 Service 和 Cluster 下面的存储中。</li>
</ul>
<h3 id="123-如何反注册"><a class="markdownIt-Anchor" href="#123-如何反注册"></a> 12.3. 如何反注册</h3>
<ul>
<li>查看 Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>查看 Cluster（服务的接口名）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>删除存储中 Service 和 Cluster 下对应的节点信息。</li>
<li>更新 Cluster 的 sign 值。</li>
</ul>
<h3 id="124-如何查询节点信息"><a class="markdownIt-Anchor" href="#124-如何查询节点信息"></a> 12.4. 如何查询节点信息</h3>
<p>首先从 localcache（本机内存）中查找，如果没有就继续下一步。</p>
<p>接着从 snapshot（本地快照）中查找，如果没有就继续下一步。</p>
<h3 id="125-如何订阅服务变更"><a class="markdownIt-Anchor" href="#125-如何订阅服务变更"></a> 12.5. 如何订阅服务变更</h3>
<ul>
<li>服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的 sign 值。</li>
<li>服务消费者每隔一段时间，调用 getSign() 函数，从注册中心获取服务端该 Cluster 的 sign 值，并与本地保留的 sign 值做对比，如果不一致，就从服务端拉取新的节点信息，并更新 localcache 和 snapshot。</li>
</ul>
<h3 id="126-注册与发现的几个问题"><a class="markdownIt-Anchor" href="#126-注册与发现的几个问题"></a> 12.6. 注册与发现的几个问题</h3>
<ul>
<li>
<p>多注册中心</p>
</li>
<li>
<p>并行订阅服务</p>
</li>
<li>
<p>批量反注册服务</p>
</li>
<li>
<p>服务变更信息增量更新</p>
</li>
</ul>
<h2 id="13-开源服务注册中心如何选型"><a class="markdownIt-Anchor" href="#13-开源服务注册中心如何选型"></a> 13. 开源服务注册中心如何选型？</h2>
<ul>
<li><strong>应用内注册与发现</strong>：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。典型代表：Eureka</li>
<li><strong>应用外注册与发现</strong>：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。典型代表：Consul</li>
</ul>
<p>二者对比：</p>
<ul>
<li>用内的解决方案一般适用于服务提供者和服务消费者同属于一个技术体系；</li>
<li>应用外的解决方案一般适合服务提供者和服务消费者采用了不同技术体系的业务场景</li>
</ul>
<p>注册中心选型要考虑的两个问题</p>
<ul>
<li>高可用性</li>
<li>数据一致性
<ul>
<li>CP 型：牺牲可用性来保证数据强一致性。代表：ZooKeeper、Etcd、Consul</li>
<li>AP 型：代表：Eureka、Nacos</li>
</ul>
</li>
</ul>
<p>而对于注册中心来说，最主要的功能是服务的注册和发现，在网络出现问题的时候，可用性的需求要远远高于数据一致性。即使因为数据不一致，注册中心内引入了不可用的服务节点，也可以通过其他措施来避免，比如客户端的快速失败机制等，只要实现最终一致性，对于注册中心来说就足够了。因此，选择 AP 型注册中心，一般更加合适。</p>
<h2 id="14-开源-rpc-框架如何选型"><a class="markdownIt-Anchor" href="#14-开源-rpc-框架如何选型"></a> 14. 开源 RPC 框架如何选型？</h2>
<p>限定语言 RPC</p>
<ul>
<li>Dubbo：仅支持 Java</li>
<li>Motan：仅支持 Java</li>
<li>Tars：仅支持 C++</li>
<li>Spring Cloud：仅支持 Java</li>
</ul>
<p>跨语言 RPC</p>
<ul>
<li>gRPC：支持 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言</li>
<li>Thrift：支持 C++、Java、PHP、Python、Ruby、Erlang 等多种语言</li>
</ul>
<h2 id="15-如何搭建一个可靠的监控系统"><a class="markdownIt-Anchor" href="#15-如何搭建一个可靠的监控系统"></a> 15. 如何搭建一个可靠的监控系统？</h2>
<p>日志解决方案：<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">ELK</a></p>
<p>时序数据库解决方案：<a href="http://graphite.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Graphite</a>、<a href="https://www.influxdata.com/time-series-platform/" target="_blank" rel="noopener">TICK</a>和<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a></p>
<h2 id="16-如何搭建一套适合你的服务追踪系统"><a class="markdownIt-Anchor" href="#16-如何搭建一套适合你的服务追踪系统"></a> 16. 如何搭建一套适合你的服务追踪系统？</h2>
<p>代表：Zipkin、PinPoint</p>
<h2 id="17-如何识别服务节点是否存活"><a class="markdownIt-Anchor" href="#17-如何识别服务节点是否存活"></a> 17. 如何识别服务节点是否存活？</h2>
<h3 id="171-心跳开关保护机制"><a class="markdownIt-Anchor" href="#171-心跳开关保护机制"></a> 17.1. 心跳开关保护机制</h3>
<p>问题：服务消费者同时并发访问注册中心获取最新服务信息导致注册中心带宽被打满</p>
<p>方案：需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。</p>
<h3 id="172-服务节点摘除保护机制"><a class="markdownIt-Anchor" href="#172-服务节点摘除保护机制"></a> 17.2. 服务节点摘除保护机制</h3>
<p>问题：服务提供者节点被大量摘除导致服务消费者没有足够的节点可以调用</p>
<p>方案：需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。</p>
<p>静态注册中心</p>
<h2 id="18-如何使用负载均衡算法"><a class="markdownIt-Anchor" href="#18-如何使用负载均衡算法"></a> 18. 如何使用负载均衡算法？</h2>
<h3 id="181-负载均衡算法"><a class="markdownIt-Anchor" href="#181-负载均衡算法"></a> 18.1. 负载均衡算法</h3>
<ul>
<li>
<p><strong>随机算法</strong></p>
</li>
<li>
<p><strong>轮询算法</strong></p>
</li>
<li>
<p><strong>加权轮询算法</strong></p>
</li>
<li>
<p><strong>最少活跃连接算法</strong></p>
</li>
<li>
<p><strong>一致性 hash 算法</strong></p>
</li>
</ul>
<h2 id="19-如何使用服务路由"><a class="markdownIt-Anchor" href="#19-如何使用服务路由"></a> 19. 如何使用服务路由？</h2>
<p><strong>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求</strong>。</p>
<p>服务路由的应用场景</p>
<ul>
<li><strong>分组调用</strong></li>
<li><strong>灰度发布</strong></li>
<li><strong>流量切换</strong></li>
<li><strong>读写分离</strong></li>
</ul>
<p>服务路由的规则</p>
<ul>
<li>条件路由
<ul>
<li>排除某个服务节点</li>
<li>白名单和黑名单功能</li>
<li>机房隔离</li>
<li>读写分离</li>
</ul>
</li>
<li>脚本路由</li>
</ul>
<p>服务路由的获取方式</p>
<ul>
<li>本地配置</li>
<li>配置中心管理</li>
<li>动态下发</li>
</ul>
<h2 id="20-服务端出现故障时该如何应对"><a class="markdownIt-Anchor" href="#20-服务端出现故障时该如何应对"></a> 20. 服务端出现故障时该如何应对？</h2>
<p>微服务故障种类</p>
<ul>
<li>集群故障。解决：流量控制
<ul>
<li>限流</li>
<li>降级</li>
</ul>
</li>
<li>单 IDC 故障。解决：多 IDC 部署、流量切换
<ul>
<li>多 IDC 部署
<ul>
<li>同城多活</li>
<li>异地多活</li>
</ul>
</li>
<li>流量切换
<ul>
<li>DNS 解析流量切换</li>
<li>RPC 流量切换</li>
</ul>
</li>
</ul>
</li>
<li>单机故障</li>
</ul>
<h2 id="21-服务调用失败时有哪些处理手段"><a class="markdownIt-Anchor" href="#21-服务调用失败时有哪些处理手段"></a> 21. 服务调用失败时有哪些处理手段？</h2>
<p>超时</p>
<p>重试</p>
<p>流量控制</p>
<h2 id="22-如何管理服务配置"><a class="markdownIt-Anchor" href="#22-如何管理服务配置"></a> 22. 如何管理服务配置？</h2>
<p>配置类型：</p>
<ul>
<li>本地配置</li>
<li>配置中心</li>
</ul>
<p>配置中心代表：</p>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">Spring Cloud Config</a></li>
<li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo</a></li>
</ul>
<h2 id="23-如何搭建微服务治理平台"><a class="markdownIt-Anchor" href="#23-如何搭建微服务治理平台"></a> 23. 如何搭建微服务治理平台？</h2>
<p>服务管理</p>
<ul>
<li>服务上下线</li>
<li>节点添加 / 删除</li>
<li>服务查询</li>
<li>服务节点查询。这个操作会调用注册中心的节点查询接口，来查询某个服务下一共有多少个节点。</li>
</ul>
<p>服务治理</p>
<ul>
<li>限流</li>
<li>降级</li>
<li>切流量</li>
</ul>
<p>服务监控</p>
<p>问题定位</p>
<p>日志查询</p>
<p>服务运维</p>
<ul>
<li>发布部署</li>
<li>弹性伸缩</li>
</ul>
<h2 id="24-微服务架构该如何落地"><a class="markdownIt-Anchor" href="#24-微服务架构该如何落地"></a> 24. 微服务架构该如何落地？</h2>
<p>（略）</p>
<h2 id="25-微服务为什么要容器化"><a class="markdownIt-Anchor" href="#25-微服务为什么要容器化"></a> 25. 微服务为什么要容器化？</h2>
<p>微服务引入的问题</p>
<p>设计复杂</p>
<p>测试复杂</p>
<p>运维困难</p>
<h2 id="26-微服务容器化运维镜像仓库和资源调度"><a class="markdownIt-Anchor" href="#26-微服务容器化运维镜像仓库和资源调度"></a> 26. 微服务容器化运维：镜像仓库和资源调度</h2>
<p>容器运维平台的组成部分</p>
<ul>
<li>镜像仓库</li>
<li>资源调度</li>
<li>容器调度</li>
<li>服务编排</li>
</ul>
<h2 id="27-微服务容器化运维容器调度和服务编排"><a class="markdownIt-Anchor" href="#27-微服务容器化运维容器调度和服务编排"></a> 27. 微服务容器化运维：容器调度和服务编排</h2>
<p>容器调度系统代表：<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Swarm</a>、<a href="http://mesos.apache.org/" target="_blank" rel="noopener">Mesos</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a></p>
<p>容器调度要解决的问题</p>
<ul>
<li><strong>主机过滤</strong>
<ul>
<li>存活过滤</li>
<li>硬件过滤</li>
</ul>
</li>
<li><strong>调度策略</strong></li>
<li><strong>服务编排</strong></li>
<li><strong>服务依赖</strong>：代表方案：<a href="https://github.com/docker/compose" target="_blank" rel="noopener">Docker Compose</a></li>
<li><strong>服务发现</strong>
<ul>
<li>基于 Nginx 的服务发现</li>
<li>基于注册中心的服务发现</li>
<li>弹性伸缩</li>
</ul>
</li>
</ul>
<h2 id="28-微服务容器化运维微博容器运维平台-dcp"><a class="markdownIt-Anchor" href="#28-微服务容器化运维微博容器运维平台-dcp"></a> 28. 微服务容器化运维：微博容器运维平台 DCP</h2>
<h2 id="29-微服务如何实现-devops"><a class="markdownIt-Anchor" href="#29-微服务如何实现-devops"></a> 29. 微服务如何实现 DevOps？</h2>
<ul>
<li><strong>CI（Continuous Integration）</strong>，持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。
<ul>
<li>代码检查</li>
<li>单元测试</li>
<li>集成测试</li>
</ul>
</li>
<li><strong>CD（Continuous Deploy）</strong>，持续部署。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li>
</ul>
<h2 id="30-如何做好微服务容量规划"><a class="markdownIt-Anchor" href="#30-如何做好微服务容量规划"></a> 30. 如何做好微服务容量规划？</h2>
<p>微服务容量规划的问题</p>
<ul>
<li>服务数量众多</li>
<li>服务的接口表现差异巨大</li>
<li>服务部署的集群规模大小不同</li>
<li>服务之间还存在依赖关系</li>
</ul>
<p>容量规划系统的作用是<strong>根据各个微服务部署集群的最大容量和线上实际运行的负荷，来决定各个微服务是否需要弹性扩缩容，以及需要扩缩容多少台机器</strong>。</p>
<p>容量规划系统实施的关键在于两点：</p>
<ul>
<li>容量评估
<ul>
<li>选择合适的压测指标
<ul>
<li>系统类指标：CPU、内存、I/O、带宽等</li>
<li>服务类指标：响应时间、P999 耗时、错误率等</li>
</ul>
</li>
<li>压测获取单机的最大容量
<ul>
<li>单机压测
<ul>
<li>通过日志回放等手段，模拟线上流量来对单机进行压测；</li>
<li>通过 TCP-Copy 的方式，把线上机器的流量拷贝过来对单机进行压测。</li>
</ul>
</li>
<li>集群压测</li>
</ul>
</li>
<li>实时和获取集群的运行负荷</li>
</ul>
</li>
<li>调度决策
<ul>
<li>可以使用<strong>水位线</strong>来进行调度决策：当集群的水位线位于致命线以下时，就需要立即扩容，在扩容一定数量的机器后，水位线回到安全线以上并保持一段时间后，就可以进行缩容了。</li>
<li>扩容
<ul>
<li>按数量</li>
<li>按比例</li>
</ul>
</li>
<li>缩容</li>
<li>逐步缩容</li>
<li>为了避免因扩容、缩容导致的水位线抖动，可以多次采集水位线数据，超过 60% 数据满足库哦哦让条件，才真正触发扩容。</li>
</ul>
</li>
</ul>
<h2 id="31-微服务多机房部署实践"><a class="markdownIt-Anchor" href="#31-微服务多机房部署实践"></a> 31. 微服务多机房部署实践</h2>
<p>多机房负载均衡：利用七层负载均衡和四层负载均衡，将流量根据用户就近访问的原则切分流量。</p>
<h2 id="32-多机房数据同步"><a class="markdownIt-Anchor" href="#32-多机房数据同步"></a> 32. 多机房数据同步</h2>
<h4 id="主从机房架构"><a class="markdownIt-Anchor" href="#主从机房架构"></a> 主从机房架构</h4>
<ul>
<li>由主机房的处理机来更新本机房的缓存和数据库</li>
<li>其他机房的缓存也通过主机房的处理机来更新</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<h4 id="独立机房架构"><a class="markdownIt-Anchor" href="#独立机房架构"></a> 独立机房架构</h4>
<ul>
<li>每个机房的处理机接收到写请求后更新各自机房的缓存</li>
<li>只有主机房会更新数据库</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<p>WMB 消息同步组件的功能就是把一个机房的写请求发给另外一个机房</p>
<ul>
<li>reship，负责把本机房的写请求分发一份给别的机房。</li>
<li>collector，负责从别的机房读取写请求，然后再把请求转发给本机房的处理机。</li>
</ul>
<p>实现 WMB 的消息同步功能有两种方案：</p>
<ul>
<li>MQ：两个机房的 MQ 通过维护状态机来读写请求</li>
<li>RPC</li>
</ul>
<h4 id="多机房数据一致性"><a class="markdownIt-Anchor" href="#多机房数据一致性"></a> 多机房数据一致性</h4>
<h2 id="33-微服务混合云部署实践"><a class="markdownIt-Anchor" href="#33-微服务混合云部署实践"></a> 33. 微服务混合云部署实践</h2>
<h3 id="331-跨云服务的负载均衡"><a class="markdownIt-Anchor" href="#331-跨云服务的负载均衡"></a> 33.1. 跨云服务的负载均衡</h3>
<p>当服务上云后还需要考虑把一定比例的用户请求路由到云上部署的服务</p>
<h3 id="332-跨云服务的数据同步"><a class="markdownIt-Anchor" href="#332-跨云服务的数据同步"></a> 33.2. 跨云服务的数据同步</h3>
<p>私有云与公有云之间的网络隔离</p>
<p>一般来讲，出于安全的需要，企业内部机房同公有云机房之间的网络是隔离的，为了实现互通，需要架设专门的 VPN 网络或者专线。</p>
<p>数据库能否上云</p>
<p>数据库能否上云的关键取决于数据的隐私性。</p>
<h3 id="333-跨云服务的容器运维"><a class="markdownIt-Anchor" href="#333-跨云服务的容器运维"></a> 33.3. 跨云服务的容器运维</h3>
<p>跨云的主机管理：跨云主机管理的关键点在于，如何对内部私有云的机器和公有云的 ECS 进行管理，</p>
<p>跨云服务发现</p>
<p>跨云弹性扩容</p>
<p>跨云服务编排</p>
<h2 id="34-下一代微服务架构-service-mesh"><a class="markdownIt-Anchor" href="#34-下一代微服务架构-service-mesh"></a> 34. 下一代微服务架构 Service Mesh</h2>
<p>为什么需要 Service Mesh</p>
<ul>
<li>
<p>跨语言服务调用的需要</p>
</li>
<li>
<p>云原生应用服务治理的需要</p>
</li>
</ul>
<h2 id="35-service-mesh-的实现原理"><a class="markdownIt-Anchor" href="#35-service-mesh-的实现原理"></a> 35. Service Mesh 的实现原理</h2>
<p>Service Mesh 实现的关键点：</p>
<ul>
<li>轻量级网络代理 SideCar，它的作用就是转发服务之间的调用；</li>
<li>基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>请求路由</li>
<li>故障处理</li>
<li>安全认证</li>
<li>监控上报</li>
<li>日志记录</li>
<li>配额控制</li>
</ul>
<h2 id="36-istioservice-mesh-的代表产品"><a class="markdownIt-Anchor" href="#36-istioservice-mesh-的代表产品"></a> 36. Istio：Service Mesh 的代表产品</h2>
<h3 id="361-istio-整体架构"><a class="markdownIt-Anchor" href="#361-istio-整体架构"></a> 36.1. Istio 整体架构</h3>
<p>Istio 的架构可以说由两部分组成，分别是 Proxy 和 Control Plane。</p>
<ul>
<li>Proxy，就是前面提到的 SideCar，与应用程序部署在同一个主机上，应用程序之间的调用都通过 Proxy 来转发，目前支持 HTTP/1.1、HTTP/2、gRPC 以及 TCP 请求。</li>
<li>Control Plane，与 Proxy 通信，来实现各种服务治理功能，包括三个基本组件：Pilot、Mixer 以及 Citadel。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">左耳听风学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 15:27:00" itemprop="dateCreated datePublished" datetime="2021-08-15T15:27:00+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="note/左耳听风学习笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>375</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="左耳听风学习笔记"><a class="markdownIt-Anchor" href="#左耳听风学习笔记"></a> 左耳听风学习笔记</h1>
<h2 id="洞悉技术的本质"><a class="markdownIt-Anchor" href="#洞悉技术的本质"></a> 洞悉技术的本质</h2>
<h2 id="分布式系统架构的本质"><a class="markdownIt-Anchor" href="#分布式系统架构的本质"></a> 分布式系统架构的本质</h2>
<p>分布式系统架构的优点：</p>
<ul>
<li>高性能</li>
<li>高可用</li>
</ul>
<p>分布式系统架构的缺点：</p>
<ul>
<li>设计复杂</li>
<li>运维复杂</li>
</ul>
<p>分布式系统的技术栈</p>
<p>提高性能的技术</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>异步</li>
<li>分片</li>
</ul>
<p>提供可用性的技术</p>
<ul>
<li>服务拆分</li>
<li>服务冗余</li>
<li>流量控制</li>
<li>高可用架构：多租户、多活架构、灾备</li>
<li>高可用运维：监控、DevOps</li>
</ul>
<p>分布式系统的关键技术</p>
<ul>
<li>服务治理</li>
<li>服务、资源调度</li>
<li>DevOps</li>
<li>监控</li>
</ul>
<h2 id="编程范式游记"><a class="markdownIt-Anchor" href="#编程范式游记"></a> 编程范式游记</h2>
<h2 id="分布式系统设计模式"><a class="markdownIt-Anchor" href="#分布式系统设计模式"></a> 分布式系统设计模式</h2>
<h2 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h2>
<h2 id="程序员练级攻略"><a class="markdownIt-Anchor" href="#程序员练级攻略"></a> 程序员练级攻略</h2>
<h2 id="面试攻略"><a class="markdownIt-Anchor" href="#面试攻略"></a> 面试攻略</h2>
<h2 id="高效学习"><a class="markdownIt-Anchor" href="#高效学习"></a> 高效学习</h2>
<p>浅度学习和深度学习</p>
<ul>
<li><strong>高质量的信息源和第一手的知识</strong>。</li>
<li><strong>把知识连成地图，将自己的理解反述出来</strong>。</li>
<li><strong>不断地反思和思辨，与不同年龄段的人讨论</strong>。</li>
<li><strong>举一反三，并践行之，把知识转换成技能</strong>。</li>
</ul>
<p>深度，归纳和坚持实践</p>
<ol>
<li><strong>这个技术出现的背景、初衷和目标</strong>。</li>
<li><strong>这个技术的优势和劣势分别是什么</strong></li>
<li><strong>这个技术适用的场景</strong></li>
<li><strong>技术的组成部分和关键点</strong>。</li>
<li><strong>技术的底层原理和关键实现</strong>。</li>
<li><strong>已有的实现和它之间的对比</strong>。</li>
</ol>
<h2 id="高效沟通"><a class="markdownIt-Anchor" href="#高效沟通"></a> 高效沟通</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/" class="post-title-link" itemprop="url">高并发系统设计40问学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 23:42:00" itemprop="dateCreated datePublished" datetime="2021-08-05T23:42:00+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="note/高并发系统设计40问/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高并发系统设计-40-问学习笔记"><a class="markdownIt-Anchor" href="#高并发系统设计-40-问学习笔记"></a> 高并发系统设计 40 问学习笔记</h1>
<h2 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h2>
<h3 id="高并发系统它的通用设计方法是什么"><a class="markdownIt-Anchor" href="#高并发系统它的通用设计方法是什么"></a> 高并发系统：它的通用设计方法是什么？</h3>
<p>并发、异步、缓存</p>
<h3 id="架构分层我们为什么一定要这么做"><a class="markdownIt-Anchor" href="#架构分层我们为什么一定要这么做"></a> 架构分层：我们为什么一定要这么做？</h3>
<p>分层架构典型代表：</p>
<ul>
<li>MVC（Model-View-Controller）</li>
<li>表现层、逻辑层和数据访问层</li>
<li>OSI 七层网络模型</li>
</ul>
<p>分层的好处</p>
<ul>
<li><strong>分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。</strong></li>
<li><strong>再有，分层之后可以做到很高的复用。</strong></li>
<li><strong>分层架构可以让我们更容易做横向扩展。</strong></li>
</ul>
<p>分层架构的不足</p>
<ul>
<li>增加了代码的复杂度</li>
</ul>
<h3 id="系统设计目标一如何提升系统性能"><a class="markdownIt-Anchor" href="#系统设计目标一如何提升系统性能"></a> 系统设计目标（一）：如何提升系统性能？</h3>
<p>讲述了性能指标和性能量化方式。</p>
<h3 id="系统设计目标二系统怎样做到高可用"><a class="markdownIt-Anchor" href="#系统设计目标二系统怎样做到高可用"></a> 系统设计目标（二）：系统怎样做到高可用？</h3>
<p>故障转移</p>
<ul>
<li>健康检查：心跳检测</li>
<li>选举：Paxos、Raft</li>
<li>负载均衡</li>
</ul>
<p>流量控制：</p>
<ul>
<li>超时与重试</li>
<li>限流</li>
<li>降级</li>
</ul>
<p>系统运维</p>
<ul>
<li>灰度发布</li>
<li>故障演练</li>
<li>CI/CD</li>
</ul>
<p>多活架构</p>
<h3 id="系统设计目标三如何让系统易于扩展"><a class="markdownIt-Anchor" href="#系统设计目标三如何让系统易于扩展"></a> 系统设计目标（三）：如何让系统易于扩展？</h3>
<p><strong>拆分首先考虑的维度是业务维度</strong></p>
<p>其次，当吞吐量达到单机瓶颈，针对存储做水平差费</p>
<h2 id="数据库篇"><a class="markdownIt-Anchor" href="#数据库篇"></a> 数据库篇</h2>
<h4 id="池化技术如何减少频繁创建数据库连接的性能损耗"><a class="markdownIt-Anchor" href="#池化技术如何减少频繁创建数据库连接的性能损耗"></a> 池化技术：如何减少频繁创建数据库连接的性能损耗？</h4>
<p>池化技术解决频繁创建连接、创建对象的成本</p>
<h3 id="数据库优化方案一查询请求增加时如何做主从分离"><a class="markdownIt-Anchor" href="#数据库优化方案一查询请求增加时如何做主从分离"></a> 数据库优化方案（一）：查询请求增加时，如何做主从分离？</h3>
<p>读写分离：写入时只写主库，在读数据时只读从库。通常采用一主多从架构。</p>
<p>读写分离的问题：<strong>主从同步的延迟</strong></p>
<p>读写分离的关键：</p>
<ul>
<li>主从复制</li>
<li>读写流量分发</li>
<li>代理：Cobar、Mycat</li>
<li>客户端：sharding-jdbc、TDDL</li>
</ul>
<h3 id="数据库优化方案二写入数据量增加时如何实现分库分表"><a class="markdownIt-Anchor" href="#数据库优化方案二写入数据量增加时如何实现分库分表"></a> 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？</h3>
<p>垂直拆分：从业务维度，将表分为不同的库</p>
<p>水平拆分：分区 key 是关键。应使用合理策略，分库分表。如：hash 取 mod 法、范围划分</p>
<h3 id="发号器如何保证分库分表后-id-的全局唯一性"><a class="markdownIt-Anchor" href="#发号器如何保证分库分表后-id-的全局唯一性"></a> 发号器：如何保证分库分表后 ID 的全局唯一性？</h3>
<p>分布式 ID：UUID、Snowflake 算法</p>
<h3 id="nosql在高并发场景下数据库和-nosql-如何做到互补"><a class="markdownIt-Anchor" href="#nosql在高并发场景下数据库和-nosql-如何做到互补"></a> NoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？</h3>
<p>LSM 树：牺牲了一定的读性能来换取写入数据的高性能，Hbase、Cassandra、LevelDB 都是用这种算法作为存储的引擎。</p>
<p>数据首先会写入到一个叫做 MemTable 的内存结构中，在 MemTable 中数据是按照写入的 Key 来排序的。为了防止 MemTable 里面的数据因为机器掉电或者重启而丢失，一般会通过写 Write Ahead Log 的方式将数据备份在磁盘上。</p>
<p>MemTable 在累积到一定规模时，它会被刷新生成一个新的文件，我们把这个文件叫做 SSTable（Sorted String Table）。当 SSTable 达到一定数量时，我们会将这些 SSTable 合并，减少文件的数量，因为 SSTable 都是有序的，所以合并的速度也很快。</p>
<p>当从 LSM 树里面读数据时，我们首先从 MemTable 中查找数据，如果数据没有找到，再从 SSTable 中查找数据。因为存储的数据都是有序的，所以查找的效率是很高的，只是因为数据被拆分成多个 SSTable，所以读取的效率会低于 B+ 树索引。</p>
<h2 id="缓存篇"><a class="markdownIt-Anchor" href="#缓存篇"></a> 缓存篇</h2>
<h3 id="缓存数据库成为瓶颈后动态数据的查询要如何加速"><a class="markdownIt-Anchor" href="#缓存数据库成为瓶颈后动态数据的查询要如何加速"></a> 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？</h3>
<p>缓存分类：静态缓存、进程内缓存、分布式缓存</p>
<h3 id="缓存的使用姿势一如何选择缓存的读写策略"><a class="markdownIt-Anchor" href="#缓存的使用姿势一如何选择缓存的读写策略"></a> 缓存的使用姿势（一）：如何选择缓存的读写策略？</h3>
<h3 id="cache-aside旁路缓存策略"><a class="markdownIt-Anchor" href="#cache-aside旁路缓存策略"></a> Cache Aside（旁路缓存）策略</h3>
<p>先写表，再写缓存，可能会导致缓存和数据库数据不一致</p>
<p>更新表，删除缓存 key；读数据时，从表中读取。</p>
<p><strong>读策略的步骤</strong></p>
<ul>
<li>从缓存中读取数据；</li>
<li>如果缓存命中，则直接返回数据；</li>
<li>如果缓存不命中，则从数据库中查询数据；</li>
<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>
</ul>
<p><strong>写策略的步骤</strong></p>
<ul>
<li>更新数据库中的记录；</li>
<li>删除缓存记录。</li>
</ul>
<p>Cache Aside 理论上还是有较小概率导致数据不一致。</p>
<p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</p>
<p><strong>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</strong></p>
<ol>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。</li>
</ol>
<h4 id="readwrite-through读穿-写穿策略"><a class="markdownIt-Anchor" href="#readwrite-through读穿-写穿策略"></a> Read/Write Through（读穿 / 写穿）策略</h4>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210155.jpg" alt="" /></p>
<h3 id="write-back写回策略"><a class="markdownIt-Anchor" href="#write-back写回策略"></a> Write Back（写回）策略</h3>
<p>核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210420.jpg" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210511.jpg" alt="" /></p>
<p>这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。</p>
<p>但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p>
<h3 id="缓存的使用姿势二缓存如何做到高可用"><a class="markdownIt-Anchor" href="#缓存的使用姿势二缓存如何做到高可用"></a> 缓存的使用姿势（二）：缓存如何做到高可用？</h3>
<p><strong>分布式缓存的高可用方案</strong></p>
<ul>
<li>客户端方案：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</li>
<li>代理层方案：客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</li>
<li>服务度方案：Redis Sentinel 方案</li>
</ul>
<h3 id="缓存的使用姿势三缓存穿透了怎么办"><a class="markdownIt-Anchor" href="#缓存的使用姿势三缓存穿透了怎么办"></a> 缓存的使用姿势（三）：缓存穿透了怎么办？</h3>
<p>缓存穿透解決方案：</p>
<ul>
<li>保存 null 值</li>
<li>布隆过滤器</li>
</ul>
<h2 id="消息队列篇"><a class="markdownIt-Anchor" href="#消息队列篇"></a> 消息队列篇</h2>
<h3 id="消息队列秒杀时如何处理每秒上万次的下单请求"><a class="markdownIt-Anchor" href="#消息队列秒杀时如何处理每秒上万次的下单请求"></a> 消息队列：秒杀时如何处理每秒上万次的下单请求？</h3>
<p>削峰、异步处理、系统解耦</p>
<h3 id="消息投递如何保证消息仅仅被消费一次"><a class="markdownIt-Anchor" href="#消息投递如何保证消息仅仅被消费一次"></a> 消息投递：如何保证消息仅仅被消费一次？</h3>
<h3 id="系统架构每秒-1-万次请求的系统要做服务化拆分吗"><a class="markdownIt-Anchor" href="#系统架构每秒-1-万次请求的系统要做服务化拆分吗"></a> 系统架构：每秒 1 万次请求的系统要做服务化拆分吗？</h3>
<p>系统中，使用的资源出现扩展性问题，尤其是数据库的连接数出现瓶颈；</p>
<p>大团队共同维护一套代码，带来研发效率的降低，和研发成本的提升；</p>
<p>系统部署成本越来越高。</p>
<h3 id="微服务架构微服务化后系统架构要如何改造"><a class="markdownIt-Anchor" href="#微服务架构微服务化后系统架构要如何改造"></a> 微服务架构：微服务化后，系统架构要如何改造？</h3>
<p>服务拆分时要遵循哪些原则？</p>
<p>服务的边界如何确定？服务的粒度是怎样呢？</p>
<p>在服务化之后，会遇到哪些问题呢？我们又将如何来解决？</p>
<h2 id="分布式服务篇"><a class="markdownIt-Anchor" href="#分布式服务篇"></a> 分布式服务篇</h2>
<h2 id="维护篇"><a class="markdownIt-Anchor" href="#维护篇"></a> 维护篇</h2>
<h3 id="给系统加上眼睛服务端监控要怎么做"><a class="markdownIt-Anchor" href="#给系统加上眼睛服务端监控要怎么做"></a> 给系统加上眼睛：服务端监控要怎么做？</h3>
<p>CPU、内存、磁盘、网络</p>
<p><strong>道路千万条，监控第一条，监控不到位，领导两行泪</strong></p>
<p>监控指标</p>
<p>采集方式</p>
<ul>
<li>Agent</li>
<li>埋点</li>
<li>日志</li>
</ul>
<p>处理和展示</p>
<h3 id="应用性能管理用户的使用体验应该如何监控"><a class="markdownIt-Anchor" href="#应用性能管理用户的使用体验应该如何监控"></a> 应用性能管理：用户的使用体验应该如何监控？</h3>
<h3 id="压力测试怎样设计全链路压力测试平台"><a class="markdownIt-Anchor" href="#压力测试怎样设计全链路压力测试平台"></a> 压力测试：怎样设计全链路压力测试平台？</h3>
<h3 id="配置管理成千上万的配置项要如何管理"><a class="markdownIt-Anchor" href="#配置管理成千上万的配置项要如何管理"></a> 配置管理：成千上万的配置项要如何管理？</h3>
<ul>
<li>配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；</li>
<li>配置中心可以提供配置变更通知的功能，可以实现配置的热更新；</li>
<li>配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到 99.999%，甚至会是 99.9999%。</li>
</ul>
<h2 id="实战篇"><a class="markdownIt-Anchor" href="#实战篇"></a> 实战篇</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/coding/scala/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/coding/scala/" class="post-title-link" itemprop="url">一篇文章让你彻底掌握 Scala</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 15:27:00" itemprop="dateCreated datePublished" datetime="2021-04-14T15:27:00+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/coding/scala/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="coding/scala/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="scala-入门"><a class="markdownIt-Anchor" href="#scala-入门"></a> Scala 入门</h1>
<blockquote>
<p>Scala 是大数据领域的热门语言，如：Akka、Kafka，所以，想要学习大数据顶级开源项目的源码，有必要具备一定的 Scala 基础。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1. 基本语法</a></li>
<li><a href="#2-%E6%B3%A8%E9%87%8A">2. 注释</a></li>
<li><a href="#3-%E5%8F%98%E9%87%8F">3. 变量</a>
<ul>
<li><a href="#31-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">3.1. 变量类型声明</a></li>
</ul>
</li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4. 数据类型</a></li>
<li><a href="#5-%E6%95%B0%E7%BB%84">5. 数组</a></li>
<li><a href="#6-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">6. 逻辑控制语句</a>
<ul>
<li><a href="#61-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">6.1. 条件语句</a></li>
<li><a href="#62-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">6.2. 循环语句</a></li>
<li><a href="#63-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">6.3. 模式匹配</a></li>
</ul>
</li>
<li><a href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6">7. 运算符</a></li>
<li><a href="#8-%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0">8. 方法与函数</a></li>
<li><a href="#9-%E9%97%AD%E5%8C%85">9. 闭包</a></li>
<li><a href="#10-%E9%9B%86%E5%90%88">10. 集合</a>
<ul>
<li><a href="#101-%E8%BF%AD%E4%BB%A3%E5%99%A8">10.1. 迭代器</a></li>
</ul>
</li>
<li><a href="#11-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">11. 类和对象</a></li>
<li><a href="#12-trait">12. Trait</a></li>
<li><a href="#13-%E5%BC%82%E5%B8%B8">13. 异常</a></li>
<li><a href="#14-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">14. 输入输出</a>
<ul>
<li><a href="#141-%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14.1. 读取用户输入</a></li>
<li><a href="#142-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">14.2. 读取文件内容</a></li>
</ul>
</li>
<li><a href="#15-%E5%8C%85">15. 包</a>
<ul>
<li><a href="#151-%E5%AE%9A%E4%B9%89%E5%8C%85">15.1. 定义包</a></li>
<li><a href="#152-%E5%BC%95%E7%94%A8">15.2. 引用</a></li>
<li><a href="#153-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">15.3. 访问修饰符</a></li>
</ul>
</li>
<li><a href="#16-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">16. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-基本语法"><a class="markdownIt-Anchor" href="#1-基本语法"></a> 1. 基本语法</h2>
<p>Scala 基本语法需要注意以下几点：</p>
<ul>
<li><strong>区分大小写</strong> - Scala 是大小写敏感的。</li>
<li><strong>类名</strong> - 对于所有的类名的第一个字母要大写。示例：<code>class MyFirstScalaClass</code></li>
<li><strong>方法名称</strong> - 所有的方法名称的第一个字母用小写。示例：<code>def myMethodName()</code></li>
<li><strong>程序文件名</strong> - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。示例: 假设&quot;HelloWorld&quot;是对象的名称。那么该文件应保存为’HelloWorld.scala&quot;</li>
<li><strong><code>def main(args: Array[String])</code></strong> - Scala 程序从 <code>main()</code> 方法开始处理，这是每一个 Scala 程序的强制程序入口部分。</li>
<li>一行中只有空格或者带有注释，Scala 会认为其是空行，会忽略它。标记可以被空格或者注释来分割。</li>
<li>Scala 是面向行的语言，语句可以用分号（;）结束或换行符。</li>
</ul>
<h2 id="2-注释"><a class="markdownIt-Anchor" href="#2-注释"></a> 2. 注释</h2>
<p>Scala 类似 Java 支持单行和多行注释。</p>
<p>【示例】单行和多行注释</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">   * 以下程序将输出'Hello World!'</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"Hello, world!"</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-变量"><a class="markdownIt-Anchor" href="#3-变量"></a> 3. 变量</h2>
<p>在 Scala 中，使用关键词 <code>var</code> 声明变量，使用关键词 <code>val</code> 声明常量。</p>
<p>【示例】声明变量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">"Foo"</span></span><br><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">"Too"</span></span><br></pre></td></tr></table></figure>
<p>【示例】声明常量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal : <span class="type">String</span> = <span class="string">"Foo"</span></span><br></pre></td></tr></table></figure>
<h3 id="31-变量类型声明"><a class="markdownIt-Anchor" href="#31-变量类型声明"></a> 3.1. 变量类型声明</h3>
<p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br><span class="line"><span class="comment">// 声明常量类型</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br></pre></td></tr></table></figure>
<p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">val</span> myVal = <span class="string">"Hello, Scala!"</span>;</span><br><span class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型"><a class="markdownIt-Anchor" href="#4-数据类型"></a> 4. 数据类型</h2>
<p>Scala 与 Java 有着相同的数据类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">8 位有符号补码整数。数值区间为 -128 到 127</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">16 位有符号补码整数。数值区间为 -32768 到 32767</td>
</tr>
<tr>
<td style="text-align:left">Int</td>
<td style="text-align:left">32 位有符号补码整数。数值区间为 -2147483648 到 2147483647</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">64 位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td>
</tr>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">32 位, IEEE 754 标准的单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">64 位 IEEE 754 标准的双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">Char</td>
<td style="text-align:left">16 位无符号 Unicode 字符, 区间值为 U+0000 到 U+FFFF</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">字符序列</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">true 或 false</td>
</tr>
<tr>
<td style="text-align:left">Unit</td>
<td style="text-align:left">表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()。</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">null 或空引用</td>
</tr>
<tr>
<td style="text-align:left">Nothing</td>
<td style="text-align:left">Nothing 类型在 Scala 的类层级的最底端；它是任何其他类型的子类型。</td>
</tr>
<tr>
<td style="text-align:left">Any</td>
<td style="text-align:left">Any 是所有其他类的超类</td>
</tr>
<tr>
<td style="text-align:left">AnyRef</td>
<td style="text-align:left">AnyRef 类是 Scala 里所有引用类(reference class)的基类</td>
</tr>
</tbody>
</table>
<p>上表中列出的数据类型都是<strong>对象</strong>，也就是说 scala 没有 java 中的原生类型。在 scala 是可以对数字等基础类型调用方法的。</p>
<h2 id="5-数组"><a class="markdownIt-Anchor" href="#5-数组"></a> 5. 数组</h2>
<p>Scala 数组声明的语法格式：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-逻辑控制语句"><a class="markdownIt-Anchor" href="#6-逻辑控制语句"></a> 6. 逻辑控制语句</h2>
<h3 id="61-条件语句"><a class="markdownIt-Anchor" href="#61-条件语句"></a> 6.1. 条件语句</h3>
<p>【示例】条件语句</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 10"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 20"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 30"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">"无法判断 X 的值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="62-循环语句"><a class="markdownIt-Anchor" href="#62-循环语句"></a> 6.2. 循环语句</h3>
<p>和 Java 一样，Scala 支持 <code>while</code>、<code>do ... while</code>、<code>for</code> 三种循环语句。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">"Value of a: "</span> + a);</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>scala 不支持 <code>break</code> 和 <code>continue</code></strong>。但是，可以通过 <code>Breaks</code> 对象来进行循环控制。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">val</span> numList1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">val</span> numList2 = <span class="type">List</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> outer = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line">    <span class="keyword">val</span> inner = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line"></span><br><span class="line">    outer.breakable &#123;</span><br><span class="line">      <span class="keyword">for</span> (a &lt;- numList1) &#123;</span><br><span class="line">        println(<span class="string">"Value of a: "</span> + a);</span><br><span class="line">        inner.breakable &#123;</span><br><span class="line">          <span class="keyword">for</span> (b &lt;- numList2) &#123;</span><br><span class="line">            println(<span class="string">"Value of b: "</span> + b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">12</span>) &#123;</span><br><span class="line">              inner.<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// 内嵌循环中断</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// 外部循环中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-模式匹配"><a class="markdownIt-Anchor" href="#63-模式匹配"></a> 6.3. 模式匹配</h3>
<p>scala 的 <code>match</code> 对应 Java 里的 <code>switch</code>，但是写在选择器表达式之后。即： <strong>选择器 match {备选项}。</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author peng.zhang</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(matchTest(<span class="string">"two"</span>))</span><br><span class="line">    println(matchTest(<span class="string">"test"</span>))</span><br><span class="line">    println(matchTest(<span class="number">1</span>))</span><br><span class="line">    println(matchTest(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>      =&gt; <span class="string">"one"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"two"</span>  =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">"scala.Int"</span></span><br><span class="line">    <span class="keyword">case</span> _      =&gt; <span class="string">"many"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-运算符"><a class="markdownIt-Anchor" href="#7-运算符"></a> 7. 运算符</h2>
<p>Scala 含有丰富的内置运算符，包括以下几种类型：</p>
<ul>
<li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></li>
<li>关系运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
<li>位运算符：<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code> （无符号右移）</li>
<li>赋值运算符：<code>=</code></li>
</ul>
<h2 id="8-方法与函数"><a class="markdownIt-Anchor" href="#8-方法与函数"></a> 8. 方法与函数</h2>
<p>Scala 有方法与函数，二者在语义上的区别很小。</p>
<p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p>
<p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p>
<p>Scala 中使用 <code>val</code> 语句可以定义函数，<code>def</code> 语句定义方法。</p>
<p>【示例】</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">Int</span>) = x + <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-闭包"><a class="markdownIt-Anchor" href="#9-闭包"></a> 9. 闭包</h2>
<p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
<p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p>
<p>如下面这段匿名的函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>
<p>在 multiplier 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 multiplier 函数被调用时，i 被赋予一个新的值。然而，factor 不是形式参数，而是自由变量，考虑下面代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>
<p>这里我们引入一个自由变量 factor，这个变量定义在函数外面。</p>
<p>这样定义的函数变量 multiplier 成为一个&quot;闭包&quot;，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClosureDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"muliplier(1) value = "</span> + multiplier(<span class="number">1</span>))</span><br><span class="line">    println(<span class="string">"muliplier(2) value = "</span> + multiplier(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-集合"><a class="markdownIt-Anchor" href="#10-集合"></a> 10. 集合</h2>
<p>Scala 集合支持 List、Set、Map、元祖、Option。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义整型 List</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Set</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Map</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Map</span>(<span class="string">"one"</span> -&gt; <span class="number">1</span>, <span class="string">"two"</span> -&gt; <span class="number">2</span>, <span class="string">"three"</span> -&gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个不同类型元素的元组</span></span><br><span class="line"><span class="keyword">val</span> x = (<span class="number">10</span>, <span class="string">"Runoob"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Option</span></span><br><span class="line"><span class="keyword">val</span> x:<span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="101-迭代器"><a class="markdownIt-Anchor" href="#101-迭代器"></a> 10.1. 迭代器</h3>
<p>迭代器 it 的两个基本操作是 <strong>next</strong> 和 <strong>hasNext</strong>。</p>
<p>调用 <strong>it.next()</strong> 会返回迭代器的下一个元素，并且更新迭代器的状态。</p>
<p>调用 <strong>it.hasNext()</strong> 用于检测集合中是否还有元素。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> it = <span class="type">Iterator</span>(<span class="string">"Baidu"</span>, <span class="string">"Google"</span>, <span class="string">"Runoob"</span>, <span class="string">"Taobao"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (it.hasNext)&#123;</span><br><span class="line">         println(it.next())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-类和对象"><a class="markdownIt-Anchor" href="#11-类和对象"></a> 11. 类和对象</h2>
<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    println(<span class="string">"x 的坐标点 : "</span> + x);</span><br><span class="line">    println(<span class="string">"y 的坐标点 : "</span> + y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">override val xc: <span class="type">Int</span>, override val yc: <span class="type">Int</span>, val zc: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Point</span>(<span class="params">xc, yc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z: <span class="type">Int</span> = zc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, dz: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    z = z + dz</span><br><span class="line">    println(<span class="string">"x 的坐标点 : "</span> + x);</span><br><span class="line">    println(<span class="string">"y 的坐标点 : "</span> + y);</span><br><span class="line">    println(<span class="string">"z 的坐标点 : "</span> + z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> loc = <span class="keyword">new</span> <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移到一个新的位置</span></span><br><span class="line">    loc.move(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-trait"><a class="markdownIt-Anchor" href="#12-trait"></a> 12. Trait</h2>
<p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。</p>
<p>与接口不同的是，它还可以定义属性和方法的实现。</p>
<p>一般情况下 Scala 的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNotEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = !isEqual(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">xc: <span class="type">Int</span>, yc: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(obj: <span class="type">Any</span>) =</span><br><span class="line">    obj.isInstanceOf[<span class="type">Point</span>] &amp;&amp;</span><br><span class="line">      obj.asInstanceOf[<span class="type">Point</span>].x == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(p1.isNotEqual(p2))</span><br><span class="line">    println(p1.isNotEqual(p3))</span><br><span class="line">    println(p1.isNotEqual(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-异常"><a class="markdownIt-Anchor" href="#13-异常"></a> 13. 异常</h2>
<p>Scala 抛出异常的方法和 Java 一样，使用 <code>throw</code> 关键词。</p>
<p>【示例】抛出异常</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<p>【示例】捕获异常</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileNotFoundException</span>, <span class="type">FileReader</span>, <span class="type">IOException</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">"input.txt"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">"Missing file exception"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">"IO Exception"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(<span class="string">"Exiting finally..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-输入输出"><a class="markdownIt-Anchor" href="#14-输入输出"></a> 14. 输入输出</h2>
<h3 id="141-读取用户输入"><a class="markdownIt-Anchor" href="#141-读取用户输入"></a> 14.1. 读取用户输入</h3>
<p>使用 <code>scala.io.StdIn.readLine()</code> 方法读取用户输入</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StdInDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    print(<span class="string">"请输入内容: "</span>)</span><br><span class="line">    <span class="keyword">val</span> line = <span class="type">StdIn</span>.readLine()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"你输入的是: "</span> + line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="142-读取文件内容"><a class="markdownIt-Anchor" href="#142-读取文件内容"></a> 14.2. 读取文件内容</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"文件内容为:"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">"test.txt"</span>).foreach &#123;</span><br><span class="line">      print</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-包"><a class="markdownIt-Anchor" href="#15-包"></a> 15. 包</h2>
<h3 id="151-定义包"><a class="markdownIt-Anchor" href="#151-定义包"></a> 15.1. 定义包</h3>
<p>Scala 使用 <code>package</code> 关键字定义包，在 Scala 将代码定义到某个包中有两种方式：</p>
<p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure>
<p>第二种方法有些类似 C#，如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="152-引用"><a class="markdownIt-Anchor" href="#152-引用"></a> 15.2. 引用</h3>
<p>Scala 使用 <code>import</code> 关键字引用包。</p>
<figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color  <span class="comment">// 引入Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt._  <span class="comment">// 引入包内所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span></span>(evt: event.ActionEvent) &#123; <span class="comment">// java.awt.event.ActionEvent</span></span><br><span class="line">  ...  <span class="comment">// 因为引入了java.awt，所以可以省去前面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import 语句可以出现在任何地方，而不是只能在文件顶部。import 的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p>
<p>如果想要引入包中的几个成员，可以使用 selector（选取器）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.&#123;Color, Font&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="function"><span class="params">HashMap</span> =&gt;</span> JavaHashMap&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="function"><span class="params">HashMap</span> =&gt;</span> _, _&#125; <span class="comment">// 引入了util包的所有成员，但是HashMap被隐藏了</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意：**默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以 scala 开头的包，在使用时都是省去 scala.的。</p>
</blockquote>
<h3 id="153-访问修饰符"><a class="markdownIt-Anchor" href="#153-访问修饰符"></a> 15.3. 访问修饰符</h3>
<p>Scala 访问修饰符基本和 Java 的一样，分别有：private，protected，public。</p>
<p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p>
<p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">      println(<span class="string">"f"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span> </span>&#123;</span><br><span class="line">      f() <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-参考资料"><a class="markdownIt-Anchor" href="#16-参考资料"></a> 16. 参考资料</h2>
<ul>
<li><a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala 官网</a></li>
<li><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">Scala 菜鸟教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/efficiency/methodology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/efficiency/methodology/" class="post-title-link" itemprop="url">效率提升方法论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T16:00:00+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/" itemprop="url" rel="index">
                    <span itemprop="name">效率提升</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">方法论</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/efficiency/methodology/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="efficiency/methodology/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="效率提升方法论"><a class="markdownIt-Anchor" href="#效率提升方法论"></a> 效率提升方法论</h1>
<p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p>
<p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p>
<p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p>
<blockquote>
<p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p>
<p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p>
<p>——莎士比亚</p>
</blockquote>
<h2 id="5w2h"><a class="markdownIt-Anchor" href="#5w2h"></a> 5W2H</h2>
<p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p>
<p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210161837.png" alt="5W2H" /></p>
<ul>
<li>
<p><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</p>
</li>
<li>
<p><strong>what</strong> - 是什么？目的是什么？作什么工作？</p>
</li>
<li>
<p><strong>where</strong> - 何处？在哪里做？从哪里入手？</p>
</li>
<li>
<p><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</p>
</li>
<li>
<p><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</p>
</li>
<li>
<p><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</p>
</li>
<li>
<p><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p>
</li>
</ul>
<h2 id="四象限原则"><a class="markdownIt-Anchor" href="#四象限原则"></a> 四象限原则</h2>
<p><strong>四象限原则是一种时间管理方式</strong>。</p>
<p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p>
<p>事情、任务太多，时间太少，分身乏术。</p>
<p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210173335.png" alt="img" /></p>
<ul>
<li>
<p><strong>第一象限（重要而紧急</strong>）</p>
<ul>
<li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li>
<li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li>
<li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li>
</ul>
</li>
<li>
<p><strong>第二象限（重要但不紧急）</strong></p>
<ul>
<li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li>
<li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li>
<li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li>
</ul>
</li>
<li>
<p><strong>第三象限（紧急但不重要）</strong></p>
<ul>
<li>案例：电话、会议、突发的访客都属于这一类。</li>
<li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li>
</ul>
</li>
<li>
<p><strong>第四象限（不紧急也不重要）</strong></p>
<ul>
<li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li>
<li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/vpn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/vpn/" class="post-title-link" itemprop="url">网络通信之 VPN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-03 10:30:00" itemprop="dateCreated datePublished" datetime="2020-02-03T10:30:00+08:00">2020-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/vpn/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/vpn/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络通信之-vpn"><a class="markdownIt-Anchor" href="#网络通信之-vpn"></a> 网络通信之 VPN</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203095528.png" alt="img" /></p>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#vpn-%E7%9A%84%E4%BD%9C%E7%94%A8">VPN 的作用</a>
<ul>
<li><a href="#%E9%9A%90%E8%97%8F-ip-%E5%92%8C%E4%BD%8D%E7%BD%AE">隐藏 IP 和位置</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%8A%A0%E5%AF%86">通信加密</a></li>
<li><a href="#%E7%BF%BB%E5%A2%99">翻墙</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E8%A2%AB%E7%9B%91%E5%90%AC">避免被监听</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="#vpn-%E5%8D%8F%E8%AE%AE">VPN 协议</a></li>
<li><a href="#vpn-%E6%9C%8D%E5%8A%A1">VPN 服务</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN 可通过服务器、硬件、软件等多种方式实现。</p>
<p>VPN 属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。<br />
在传统的企业网络配置中，要进行远程访问，传统的方法是租用 DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。<br />
让外地员工访问到内网资源，利用 VPN 的解决方法就是在内网中架设一台 VPN 服务器。外地员工在当地连上互联网后，通过互联网连接 VPN 服务器，然后通过 VPN 服务器进入企业内网。为了保证数据安全，VPN 服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上 VPN 使用的是互联网上的公用链路，因此 VPN 称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了 VPN 技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用 VPN 访问内网资源，这就是 VPN 在企业中应用得如此广泛的原因。</p>
<h2 id="vpn-的作用"><a class="markdownIt-Anchor" href="#vpn-的作用"></a> VPN 的作用</h2>
<h3 id="隐藏-ip-和位置"><a class="markdownIt-Anchor" href="#隐藏-ip-和位置"></a> 隐藏 IP 和位置</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100404.png" alt="img" /></p>
<p>VPN 可以隐藏使用者的 IP 地址和位置。</p>
<p>使用 VPN 的最常见原因之一是屏蔽您的真实 IP 地址。</p>
<p>您的 IP 地址是由 ISP 分配的唯一数字地址。 您在线上所做的所有事情都链接到您的 IP 地址，因此可以用来将您与在线活动进行匹配。 大多数网站记录其访问者的 IP 地址。</p>
<p>广告商还可以使用您的 IP 地址，根据您的身份和浏览历史为您提供有针对性的广告。</p>
<p>连接到 VPN 服务器时，您将使用该 VPN 服务器的 IP 地址。 您访问的任何网站都会看到 VPN 服务器的 IP 地址，而不是您自己的。</p>
<p>您将能够绕过 IP 地址阻止并浏览网站，而不会将您的活动作为一个个人追溯到您。</p>
<h3 id="通信加密"><a class="markdownIt-Anchor" href="#通信加密"></a> 通信加密</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100543.png" alt="img" /></p>
<p>使用 VPN 时，可以对信息进行加密，使得密码，电子邮件，照片，银行数据和其他敏感信息不会被拦截。</p>
<p>如果在公共场所使用公共 WiFi 连接网络时，敏感数据有被盗的风险。黑客可以利用开放和未加密的网络来窃取重要数据，例如您的密码，电子邮件，照片，银行数据和其他敏感信息。</p>
<p>VPN 可以加密信息，使黑客更难以拦截和窃取数据。</p>
<h3 id="翻墙"><a class="markdownIt-Anchor" href="#翻墙"></a> 翻墙</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100706.png" alt="img" /></p>
<p>轻松解除对 Facebook 和 Twitter，Skype，YouTube 和 Gmail 等网站和服务的阻止。 即使您被告知您所在的国家/地区不可用它，或者您所在的学校或办公室网络限制访问，也可以获取所需的东西。</p>
<p>某些服务（例如 Netflix 或 BBC iPlayer）会根据您访问的国家/地区限制访问内容。使用 VPN 可以绕过这些地理限制并解锁“隐藏”内容的唯一可靠方法。</p>
<h3 id="避免被监听"><a class="markdownIt-Anchor" href="#避免被监听"></a> 避免被监听</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100933.png" alt="img" /></p>
<p>使用 VPN 可以向政府、ISP、黑客隐藏通信信息。</p>
<p>您的 Internet 服务提供商（ISP）可以看到您访问的所有网站，并且几乎可以肯定会记录该信息。</p>
<p>在某些国家/地区，ISP 需要长时间收集和存储用户数据，并且政府能够访问，存储和搜索该信息。</p>
<p>在美国，英国，澳大利亚和欧洲大部分地区就是这种情况，仅举几例。</p>
<p>由于 VPN 会加密从设备到 VPN 服务器的互联网流量，因此您的 ISP 或任何其他第三方将无法监视您的在线活动。</p>
<p>要了解有关监视技术和全球大规模监视问题的更多信息，请访问 EFF 和 Privacy International。 您还可以在此处找到全球监视披露的更新列表。</p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>VPN 会在您的设备和私人服务器之间建立私人和加密的互联网连接。 这意味着您的数据无法被 ISP 或任何其他第三方读取或理解。 然后，私有服务器将您的流量发送到您要访问的网站或服务上。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102422.png" alt="img" /></p>
<p>VPN 的基本处理过程如下：</p>
<ol>
<li>要保护主机发送明文信息到其他 VPN 设备。</li>
<li>VPN 设备根据网络管理员设置的规则，确定是对数据进行加密还是直接传输。</li>
<li>对需要加密的数据，VPN 设备将其整个数据包（包括要传输的数据、源 IP 地址和目的 lP 地址）进行加密并附上数据签名，加上新的数据报头（包括目的地 VPN 设备需要的安全信息和一些初始化参数）重新封装。</li>
<li>将封装后的数据包通过隧道在公共网络上传输。</li>
<li>数据包到达目的 VPN 设备后，将其解封，核对数字签名无误后，对数据包解密。</li>
</ol>
<h2 id="vpn-协议"><a class="markdownIt-Anchor" href="#vpn-协议"></a> VPN 协议</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102656.png" alt="img" /></p>
<ul>
<li>
<p>OpenVPN</p>
</li>
<li>
<p>IKEv2 / IPSec</p>
</li>
<li>
<p>SSTP</p>
</li>
<li>
<p>PPTP</p>
</li>
<li>
<p>Wireguard</p>
</li>
</ul>
<h2 id="vpn-服务"><a class="markdownIt-Anchor" href="#vpn-服务"></a> VPN 服务</h2>
<p>你可以选择付费 VPN 或自行搭建 VPN。</p>
<p>VPN 服务商：</p>
<ul>
<li><a href="https://go.nordvpn.net/aff_c?offer_id=15&amp;aff_id=22023&amp;url_id=902" target="_blank" rel="noopener">NordVPN</a></li>
<li><a href="https://www.linkev.com/?a_fid=techacro" target="_blank" rel="noopener">ExpressVPN</a></li>
<li><a href="https://cybertool.co/tchacrobat_fs_izci9mc6y" target="_blank" rel="noopener">CyberGhostVPN</a></li>
<li><a href="https://click.tunnelbear.com/aff_c?offer_id=36&amp;aff_id=7306" target="_blank" rel="noopener">TunnelBear</a></li>
<li><a href="https://www.ipvanish.com/" target="_blank" rel="noopener">IPVanish</a></li>
</ul>
<p>开源 VPN：</p>
<ul>
<li><a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">百度百科 - VPN</a></li>
<li><a href="https://www.expressvpn.com/what-is-vpn" target="_blank" rel="noopener">What is a VPN</a></li>
<li><a href="https://www.youtube.com/watch?v=_wQTRMBAvzg" target="_blank" rel="noopener">What is a VPN and How Does it Work</a></li>
<li><a href="https://www.top10vpn.com/guides/what-is-a-vpn/" target="_blank" rel="noopener">What Is a VPN (Virtual Private Network) and How Does It Work?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/network-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/network-interview/" class="post-title-link" itemprop="url">网络通信知识点面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/network-interview/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/network-interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>如果你不是从事于通信领域，面试时问及计算机网络的知识，一般也就限定在：HTTP（含 HTTPS、Cookie、Session）、TCP、UDP、Socket 这些</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li>
</ul>
</li>
<li><a href="#2-http">2. HTTP</a></li>
<li><a href="#3-dns">3. DNS</a></li>
<li><a href="#4-tcpudp">4. TCP/UDP</a>
<ul>
<li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li>
<li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li>
<li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li>
<li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li>
<li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li>
<li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2>
<h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3>
<blockquote>
<p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/network-layers.png"/></div>
计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/网络分层架构图.png"/></div>
**物理层**
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<p><strong>数据链路层</strong></p>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<p><strong>网络层</strong></p>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<p><strong>传输层</strong></p>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<p><sub>~**会话层**~</sub></p>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<p><sub>~**表示层**~</sub></p>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<p><strong>应用层</strong></p>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2>
<blockquote>
<p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p>
</blockquote>
<h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2>
<blockquote>
<p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p>
</blockquote>
<h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2>
<blockquote>
<p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p>
</blockquote>
<h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p>
<h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3>
<blockquote>
<p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p>
</blockquote>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div>
如上图所示，三次握手流程如下：
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3>
<blockquote>
<p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
</blockquote>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div>
1. 第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。
2. 第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。
3. 第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。
4. 第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3>
<blockquote>
<p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p>
</blockquote>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div>
1. 已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。
2. 已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 \~ 45 字节为第 2 类。
3. 未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 \~ 51 字节为第 3 类。
4. 未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div>
这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。
<h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3>
<blockquote>
<p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p>
</blockquote>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<p>（1）超时重传机制</p>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<p>（2）快速重传机制</p>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/network/tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/network/tcp/" class="post-title-link" itemprop="url">网络协议之 TCP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-31T11:51:00+08:00">2019-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 23:33:01" itemprop="dateModified" datetime="2021-08-26T23:33:01+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/network/tcp/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="network/tcp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络协议之-tcp"><a class="markdownIt-Anchor" href="#网络协议之-tcp"></a> 网络协议之 TCP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-tcp">什么是 TCP</a></li>
<li><a href="#tcp-%E7%9A%84%E7%89%B9%E6%80%A7">TCP 的特性</a></li>
<li><a href="#tcp-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">TCP 的适用场景</a></li>
<li><a href="#tcp-%E6%8A%A5%E6%96%87">TCP 报文</a></li>
</ul>
</li>
<li><a href="#tcp-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B">TCP 通信流程</a>
<ul>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
<li><a href="#tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">TCP 重传机制</a>
<ul>
<li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">快速重传机制</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559263786555.png"/></div>
<h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3>
<p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264511812.png"/></div>
<p>报文字段不一一阐述，重点关注以下几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：
<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264593860.png"/></div>
<h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264679371.png"/></div>
<p>TCP 完整的通信分为三块：</p>
<ol>
<li>三次握手建立连接</li>
<li>数据传输</li>
<li>四次挥手端口连接</li>
</ol>
<h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div>
<p>如上图所示，三次握手流程如下：</p>
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div>
<ol>
<li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li>
<li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li>
<li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li>
</ol>
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div>
<ol>
<li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li>
<li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li>
<li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li>
<li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li>
</ol>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div>
<p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p>
<h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li>
<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li>
<li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解 TCP 三次握手与四次分手</a></li>
<li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP 的三次握手与四次挥手（详解+动图）</a></li>
<li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">TCP 详解</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">143k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:10</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
